/* automatically generated by rust-bindgen 0.56.0 */
use jni_sys::{
    JNIInvokeInterface_ as JNIInvokeInterface, JNINativeInterface_ as JNINativeInterface,
};

pub const VRAPI_PRODUCT_VERSION: u32 = 1;
pub const VRAPI_MAJOR_VERSION: u32 = 1;
pub const VRAPI_MINOR_VERSION: u32 = 40;
pub const VRAPI_PATCH_VERSION: u32 = 0;
pub const VRAPI_BUILD_VERSION: u32 = 255199885;
pub const VRAPI_BUILD_DESCRIPTION: &'static [u8; 12usize] = b"Development\0";
pub const VRAPI_DRIVER_VERSION: u32 = 255199885;
pub const VRAPI_PI: f64 = 3.141592653589793;
pub const VRAPI_ZNEAR: f64 = 0.1;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type va_list = __builtin_va_list;
pub type jboolean = u8;
pub type jbyte = i8;
pub type jchar = u16;
pub type jshort = i16;
pub type jint = i32;
pub type jlong = i64;
pub type jfloat = f32;
pub type jdouble = f64;
pub type jsize = jint;
pub type jobject = jni_sys::jobject;
pub type jclass = jobject;
pub type jstring = jobject;
pub type jarray = jobject;
pub type jobjectArray = jarray;
pub type jbooleanArray = jarray;
pub type jbyteArray = jarray;
pub type jcharArray = jarray;
pub type jshortArray = jarray;
pub type jintArray = jarray;
pub type jlongArray = jarray;
pub type jfloatArray = jarray;
pub type jdoubleArray = jarray;
pub type jthrowable = jobject;
pub type jweak = jobject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jfieldID {
    _unused: [u8; 0],
}
pub type jfieldID = *mut _jfieldID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmethodID {
    _unused: [u8; 0],
}
pub type jmethodID = *mut _jmethodID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union jvalue {
    pub z: jboolean,
    pub b: jbyte,
    pub c: jchar,
    pub s: jshort,
    pub i: jint,
    pub j: jlong,
    pub f: jfloat,
    pub d: jdouble,
    pub l: jobject,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_jvalue() {
    assert_eq!(
        ::std::mem::size_of::<jvalue>(),
        8usize,
        concat!("Size of: ", stringify!(jvalue))
    );
    assert_eq!(
        ::std::mem::align_of::<jvalue>(),
        8usize,
        concat!("Alignment of ", stringify!(jvalue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).z as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).c as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).i as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).j as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(j))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).f as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).d as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).l as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(l))
    );
}
pub const jobjectRefType_JNIInvalidRefType: jobjectRefType = 0;
pub const jobjectRefType_JNILocalRefType: jobjectRefType = 1;
pub const jobjectRefType_JNIGlobalRefType: jobjectRefType = 2;
pub const jobjectRefType_JNIWeakGlobalRefType: jobjectRefType = 3;
pub type jobjectRefType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNINativeMethod {
    pub name: *const ::std::os::raw::c_char,
    pub signature: *const ::std::os::raw::c_char,
    pub fnPtr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_JNINativeMethod() {
    assert_eq!(
        ::std::mem::size_of::<JNINativeMethod>(),
        24usize,
        concat!("Size of: ", stringify!(JNINativeMethod))
    );
    assert_eq!(
        ::std::mem::align_of::<JNINativeMethod>(),
        8usize,
        concat!("Alignment of ", stringify!(JNINativeMethod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeMethod>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeMethod),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeMethod>())).signature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeMethod),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeMethod>())).fnPtr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeMethod),
            "::",
            stringify!(fnPtr)
        )
    );
}
pub type JNIEnv = *const JNINativeInterface;
pub type JavaVM = *const JNIInvokeInterface;
#[doc = " Java details about an activity"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrJava_ {
    pub Vm: *mut JavaVM,
    pub Env: *mut JNIEnv,
    pub ActivityObject: jobject,
}
#[test]
fn bindgen_test_layout_ovrJava_() {
    assert_eq!(
        ::std::mem::size_of::<ovrJava_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrJava_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrJava_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrJava_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).Vm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(Vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).Env as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(Env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).ActivityObject as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(ActivityObject)
        )
    );
}
#[doc = " Java details about an activity"]
pub type ovrJava = ovrJava_;
pub type ovrResult = ::std::os::raw::c_int;
#[repr(i32)]
#[doc = " ovrResult isn't actually an enum type and the the success / failure types are not"]
#[doc = " defined anywhere for GearVR VrApi. This needs to be remedied. For now, I'm defining"]
#[doc = " these here and will try to address this larger issue in a follow-on changeset."]
#[doc = " errors are < 0, successes are >= 0"]
#[doc = " Except where noted, these match error codes from PC CAPI."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrSuccessResult_ {
    ovrSuccess = 0,
    ovrSuccess_BoundaryInvalid = 1001,
    ovrSuccess_EventUnavailable = 1002,
    ovrSuccess_Skipped = 1003,
}
#[doc = " ovrResult isn't actually an enum type and the the success / failure types are not"]
#[doc = " defined anywhere for GearVR VrApi. This needs to be remedied. For now, I'm defining"]
#[doc = " these here and will try to address this larger issue in a follow-on changeset."]
#[doc = " errors are < 0, successes are >= 0"]
#[doc = " Except where noted, these match error codes from PC CAPI."]
pub use self::ovrSuccessResult_ as ovrSuccessResult;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrErrorResult_ {
    ovrError_MemoryAllocationFailure = -1000,
    ovrError_NotInitialized = -1004,
    ovrError_InvalidParameter = -1005,
    ovrError_DeviceUnavailable = -1010,
    ovrError_InvalidOperation = -1015,
    ovrError_UnsupportedDeviceType = -1050,
    ovrError_NoDevice = -1051,
    ovrError_NotImplemented = -1052,
    #[doc = " ovrError_NotReady is returned when a subsystem supporting an API is not yet ready."]
    #[doc = " For some subsystems, vrapi_PollEvent will return a ready event once the sub-system is"]
    #[doc = " available."]
    ovrError_NotReady = -1053,
    #[doc = " Data is unavailable"]
    ovrError_Unavailable = -1054,
    #[doc = " Data is unavailable"]
    ovrResult_EnumSize = 2147483647,
}
pub use self::ovrErrorResult_ as ovrErrorResult;
#[doc = " A 2D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector2f_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_ovrVector2f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector2f_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector2f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " A 2D vector."]
pub type ovrVector2f = ovrVector2f_;
#[doc = " A 3D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector3f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_ovrVector3f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector3f_>(),
        12usize,
        concat!("Size of: ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector3f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " A 3D vector."]
pub type ovrVector3f = ovrVector3f_;
#[doc = " A 4D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector4f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrVector4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector4f_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " A 4D vector."]
pub type ovrVector4f = ovrVector4f_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector4s_ {
    pub x: i16,
    pub y: i16,
    pub z: i16,
    pub w: i16,
}
#[test]
fn bindgen_test_layout_ovrVector4s_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector4s_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrVector4s_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector4s_>(),
        2usize,
        concat!("Alignment of ", stringify!(ovrVector4s_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4s_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4s_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4s_>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4s_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4s_>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4s_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4s_>())).w as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4s_),
            "::",
            stringify!(w)
        )
    );
}
pub type ovrVector4s = ovrVector4s_;
#[doc = " Quaternion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrQuatf_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrQuatf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrQuatf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrQuatf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " Quaternion."]
pub type ovrQuatf = ovrQuatf_;
#[doc = " Row-major 4x4 matrix."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMatrix4f_ {
    pub M: [[f32; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_ovrMatrix4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrMatrix4f_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrMatrix4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMatrix4f_>())).M as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMatrix4f_),
            "::",
            stringify!(M)
        )
    );
}
#[doc = " Row-major 4x4 matrix."]
pub type ovrMatrix4f = ovrMatrix4f_;
#[doc = " Position and orientation together."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrPosef_ {
    pub Orientation: ovrQuatf,
    pub __bindgen_anon_1: ovrPosef___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrPosef___bindgen_ty_1 {
    pub Position: ovrVector3f,
    pub Translation: ovrVector3f,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ovrPosef___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrPosef___bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ovrPosef___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPosef___bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPosef___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPosef___bindgen_ty_1>())).Position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef___bindgen_ty_1),
            "::",
            stringify!(Position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPosef___bindgen_ty_1>())).Translation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef___bindgen_ty_1),
            "::",
            stringify!(Translation)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrPosef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPosef_>(),
        28usize,
        concat!("Size of: ", stringify!(ovrPosef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPosef_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPosef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPosef_>())).Orientation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef_),
            "::",
            stringify!(Orientation)
        )
    );
}
#[doc = " Position and orientation together."]
pub type ovrPosef = ovrPosef_;
#[doc = " A rectangle with 2D size and position."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrRectf_ {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_ovrRectf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrRectf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrRectf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrRectf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrRectf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " A rectangle with 2D size and position."]
pub type ovrRectf = ovrRectf_;
#[repr(i32)]
#[doc = " True or false."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrBooleanResult_ {
    VRAPI_FALSE = 0,
    VRAPI_TRUE = 1,
}
#[doc = " True or false."]
pub use self::ovrBooleanResult_ as ovrBooleanResult;
#[repr(i32)]
#[doc = " One of the user's eyes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrEye_ {
    VRAPI_EYE_LEFT = 0,
    VRAPI_EYE_RIGHT = 1,
    VRAPI_EYE_COUNT = 2,
}
#[doc = " One of the user's eyes."]
pub use self::ovrEye_ as ovrEye;
#[repr(i32)]
#[doc = " Defines a layout for ovrInitParms, ovrModeParms, or ovrFrameParms."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrStructureType_ {
    VRAPI_STRUCTURE_TYPE_INIT_PARMS = 1,
    VRAPI_STRUCTURE_TYPE_MODE_PARMS = 2,
    VRAPI_STRUCTURE_TYPE_FRAME_PARMS = 3,
    VRAPI_STRUCTURE_TYPE_MODE_PARMS_VULKAN = 5,
}
#[doc = " Defines a layout for ovrInitParms, ovrModeParms, or ovrFrameParms."]
pub use self::ovrStructureType_ as ovrStructureType;
impl ovrDeviceType_ {
    pub const VRAPI_DEVICE_TYPE_OCULUSQUEST2: ovrDeviceType_ =
        ovrDeviceType_::VRAPI_DEVICE_TYPE_OCULUSQUEST2_START;
}
#[repr(i32)]
#[doc = " A VR-capable device."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrDeviceType_ {
    VRAPI_DEVICE_TYPE_OCULUSQUEST_START = 256,
    VRAPI_DEVICE_TYPE_OCULUSQUEST = 259,
    VRAPI_DEVICE_TYPE_OCULUSQUEST_END = 319,
    VRAPI_DEVICE_TYPE_OCULUSQUEST2_START = 320,
    VRAPI_DEVICE_TYPE_OCULUSQUEST2_END = 383,
    VRAPI_DEVICE_TYPE_UNKNOWN = -1,
}
#[doc = " A VR-capable device."]
pub use self::ovrDeviceType_ as ovrDeviceType;
#[repr(i32)]
#[doc = " A geographic region authorized for certain hardware and content."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrDeviceRegion_ {
    VRAPI_DEVICE_REGION_UNSPECIFIED = 0,
    VRAPI_DEVICE_REGION_JAPAN = 1,
    VRAPI_DEVICE_REGION_CHINA = 2,
}
#[doc = " A geographic region authorized for certain hardware and content."]
pub use self::ovrDeviceRegion_ as ovrDeviceRegion;
#[repr(i32)]
#[doc = " Emulation mode for applications developed on different devices"]
#[doc = " for determining if running in emulation mode at all test against !="]
#[doc = " VRAPI_DEVICE_EMULATION_MODE_NONE"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrDeviceEmulationMode_ {
    VRAPI_DEVICE_EMULATION_MODE_NONE = 0,
    VRAPI_DEVICE_EMULATION_MODE_GO_ON_QUEST = 1,
}
#[doc = " Emulation mode for applications developed on different devices"]
#[doc = " for determining if running in emulation mode at all test against !="]
#[doc = " VRAPI_DEVICE_EMULATION_MODE_NONE"]
pub use self::ovrDeviceEmulationMode_ as ovrDeviceEmulationMode;
#[repr(i32)]
#[doc = " System configuration properties."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrSystemProperty_ {
    VRAPI_SYS_PROP_DEVICE_TYPE = 0,
    VRAPI_SYS_PROP_MAX_FULLSPEED_FRAMEBUFFER_SAMPLES = 1,
    #[doc = " Physical width and height of the display in pixels."]
    VRAPI_SYS_PROP_DISPLAY_PIXELS_WIDE = 2,
    #[doc = " Physical width and height of the display in pixels."]
    VRAPI_SYS_PROP_DISPLAY_PIXELS_HIGH = 3,
    #[doc = " Returns the refresh rate of the display in cycles per second."]
    VRAPI_SYS_PROP_DISPLAY_REFRESH_RATE = 4,
    #[doc = " With a display resolution of 2560x1440, the pixels at the center"]
    #[doc = " of each eye cover about 0.06 degrees of visual arc. To wrap a"]
    #[doc = " full 360 degrees, about 6000 pixels would be needed and about one"]
    #[doc = " quarter of that would be needed for ~90 degrees FOV. As such, Eye"]
    #[doc = " images with a resolution of 1536x1536 result in a good 1:1 mapping"]
    #[doc = " in the center, but they need mip-maps for off center pixels. To"]
    #[doc = " avoid the need for mip-maps and for significantly improved rendering"]
    #[doc = " performance this currently returns a conservative 1024x1024."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_WIDTH = 5,
    #[doc = " With a display resolution of 2560x1440, the pixels at the center"]
    #[doc = " of each eye cover about 0.06 degrees of visual arc. To wrap a"]
    #[doc = " full 360 degrees, about 6000 pixels would be needed and about one"]
    #[doc = " quarter of that would be needed for ~90 degrees FOV. As such, Eye"]
    #[doc = " images with a resolution of 1536x1536 result in a good 1:1 mapping"]
    #[doc = " in the center, but they need mip-maps for off center pixels. To"]
    #[doc = " avoid the need for mip-maps and for significantly improved rendering"]
    #[doc = " performance this currently returns a conservative 1024x1024."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_HEIGHT = 6,
    #[doc = " This is a product of the lens distortion and the screen size,"]
    #[doc = " but there is no truly correct answer."]
    #[doc = " There is a tradeoff in resolution and coverage."]
    #[doc = " Too small of an FOV will leave unrendered pixels visible, but too"]
    #[doc = " large wastes resolution or fill rate.  It is unreasonable to"]
    #[doc = " increase it until the corners are completely covered, but we do"]
    #[doc = " want most of the outside edges completely covered."]
    #[doc = " Applications might choose to render a larger FOV when angular"]
    #[doc = " acceleration is high to reduce black pull in at the edges by"]
    #[doc = " the time warp."]
    #[doc = " Currently symmetric 90.0 degrees."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_X = 7,
    #[doc = " This is a product of the lens distortion and the screen size,"]
    #[doc = " but there is no truly correct answer."]
    #[doc = " There is a tradeoff in resolution and coverage."]
    #[doc = " Too small of an FOV will leave unrendered pixels visible, but too"]
    #[doc = " large wastes resolution or fill rate.  It is unreasonable to"]
    #[doc = " increase it until the corners are completely covered, but we do"]
    #[doc = " want most of the outside edges completely covered."]
    #[doc = " Applications might choose to render a larger FOV when angular"]
    #[doc = " acceleration is high to reduce black pull in at the edges by"]
    #[doc = " the time warp."]
    #[doc = " Currently symmetric 90.0 degrees."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_Y = 8,
    #[doc = " This is a product of the lens distortion and the screen size,"]
    #[doc = " but there is no truly correct answer."]
    #[doc = " There is a tradeoff in resolution and coverage."]
    #[doc = " Too small of an FOV will leave unrendered pixels visible, but too"]
    #[doc = " large wastes resolution or fill rate.  It is unreasonable to"]
    #[doc = " increase it until the corners are completely covered, but we do"]
    #[doc = " want most of the outside edges completely covered."]
    #[doc = " Applications might choose to render a larger FOV when angular"]
    #[doc = " acceleration is high to reduce black pull in at the edges by"]
    #[doc = " the time warp."]
    #[doc = " Currently symmetric 90.0 degrees."]
    VRAPI_SYS_PROP_DEVICE_REGION = 10,
    #[doc = " Returns an ovrHandedness enum indicating left or right hand."]
    VRAPI_SYS_PROP_DOMINANT_HAND = 15,
    #[doc = " Returns VRAPI_TRUE if the system supports orientation tracking."]
    VRAPI_SYS_PROP_HAS_ORIENTATION_TRACKING = 16,
    #[doc = " Returns VRAPI_TRUE if the system supports positional tracking."]
    VRAPI_SYS_PROP_HAS_POSITION_TRACKING = 17,
    #[doc = " Returns the number of display refresh rates supported by the system."]
    VRAPI_SYS_PROP_NUM_SUPPORTED_DISPLAY_REFRESH_RATES = 64,
    #[doc = " Returns an array of the supported display refresh rates."]
    VRAPI_SYS_PROP_SUPPORTED_DISPLAY_REFRESH_RATES = 65,
    #[doc = " Returns the number of swapchain texture formats supported by the system."]
    VRAPI_SYS_PROP_NUM_SUPPORTED_SWAPCHAIN_FORMATS = 66,
    #[doc = " Returns an array of the supported swapchain formats."]
    #[doc = " Formats are platform specific. For GLES, this is an array of"]
    #[doc = " GL internal formats."]
    VRAPI_SYS_PROP_SUPPORTED_SWAPCHAIN_FORMATS = 67,
    #[doc = " Returns VRAPI_TRUE if on-chip foveated rendering of swapchains is supported"]
    #[doc = " for this system, otherwise VRAPI_FALSE."]
    VRAPI_SYS_PROP_FOVEATION_AVAILABLE = 130,
}
#[doc = " System configuration properties."]
pub use self::ovrSystemProperty_ as ovrSystemProperty;
#[repr(i32)]
#[doc = " Configurable VrApi properties."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrProperty_ {
    VRAPI_FOVEATION_LEVEL = 15,
    VRAPI_EAT_NATIVE_GAMEPAD_EVENTS = 20,
    VRAPI_ACTIVE_INPUT_DEVICE_ID = 24,
    VRAPI_DEVICE_EMULATION_MODE = 29,
    VRAPI_DYNAMIC_FOVEATION_ENABLED = 30,
}
#[doc = " Configurable VrApi properties."]
pub use self::ovrProperty_ as ovrProperty;
#[repr(i32)]
#[doc = " System status bits."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrSystemStatus_ {
    VRAPI_SYS_STATUS_MOUNTED = 1,
    VRAPI_SYS_STATUS_THROTTLED = 2,
    VRAPI_SYS_STATUS_RENDER_LATENCY_MILLISECONDS = 5,
    VRAPI_SYS_STATUS_TIMEWARP_LATENCY_MILLISECONDS = 6,
    VRAPI_SYS_STATUS_SCANOUT_LATENCY_MILLISECONDS = 7,
    VRAPI_SYS_STATUS_APP_FRAMES_PER_SECOND = 8,
    VRAPI_SYS_STATUS_SCREEN_TEARS_PER_SECOND = 9,
    VRAPI_SYS_STATUS_EARLY_FRAMES_PER_SECOND = 10,
    VRAPI_SYS_STATUS_STALE_FRAMES_PER_SECOND = 11,
    VRAPI_SYS_STATUS_RECENTER_COUNT = 13,
    VRAPI_SYS_STATUS_USER_RECENTER_COUNT = 15,
    VRAPI_SYS_STATUS_FRONT_BUFFER_PROTECTED = 128,
    VRAPI_SYS_STATUS_FRONT_BUFFER_SRGB = 130,
    VRAPI_SYS_STATUS_SCREEN_CAPTURE_RUNNING = 131,
}
#[doc = " System status bits."]
pub use self::ovrSystemStatus_ as ovrSystemStatus;
#[repr(i32)]
#[doc = " Possible results of initialization."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrInitializeStatus_ {
    VRAPI_INITIALIZE_SUCCESS = 0,
    VRAPI_INITIALIZE_UNKNOWN_ERROR = -1,
    VRAPI_INITIALIZE_PERMISSIONS_ERROR = -2,
    VRAPI_INITIALIZE_ALREADY_INITIALIZED = -3,
    VRAPI_INITIALIZE_SERVICE_CONNECTION_FAILED = -4,
    VRAPI_INITIALIZE_DEVICE_NOT_SUPPORTED = -5,
}
#[doc = " Possible results of initialization."]
pub use self::ovrInitializeStatus_ as ovrInitializeStatus;
#[repr(i32)]
#[doc = " Supported graphics APIs."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrGraphicsAPI_ {
    VRAPI_GRAPHICS_API_TYPE_OPENGL_ES = 65536,
    VRAPI_GRAPHICS_API_OPENGL_ES_2 = 66048,
    VRAPI_GRAPHICS_API_OPENGL_ES_3 = 66304,
    VRAPI_GRAPHICS_API_TYPE_OPENGL = 131072,
    VRAPI_GRAPHICS_API_OPENGL_COMPAT = 131328,
    VRAPI_GRAPHICS_API_OPENGL_CORE_3 = 131840,
    VRAPI_GRAPHICS_API_OPENGL_CORE_4 = 132096,
    VRAPI_GRAPHICS_API_TYPE_VULKAN = 262144,
    VRAPI_GRAPHICS_API_VULKAN_1 = 262400,
}
#[doc = " Supported graphics APIs."]
pub use self::ovrGraphicsAPI_ as ovrGraphicsAPI;
#[doc = " Configuration details specified at initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInitParms_ {
    pub Type: ovrStructureType,
    pub ProductVersion: ::std::os::raw::c_int,
    pub MajorVersion: ::std::os::raw::c_int,
    pub MinorVersion: ::std::os::raw::c_int,
    pub PatchVersion: ::std::os::raw::c_int,
    pub GraphicsAPI: ovrGraphicsAPI,
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrInitParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInitParms_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrInitParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInitParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInitParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).ProductVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(ProductVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).MajorVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).MinorVersion as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).PatchVersion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(PatchVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).GraphicsAPI as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(GraphicsAPI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).Java as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(Java)
        )
    );
}
#[doc = " Configuration details specified at initialization."]
pub type ovrInitParms = ovrInitParms_;
#[repr(i32)]
#[doc = " \\note the first two flags use the first two bytes for backwards compatibility on little endian"]
#[doc = " systems."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrModeFlags_ {
    #[doc = " When an application moves backwards on the activity stack,"]
    #[doc = " the activity window it returns to is no longer flagged as fullscreen."]
    #[doc = " As a result, Android will also render the decor view, which wastes a"]
    #[doc = " significant amount of bandwidth."]
    #[doc = " By setting this flag, the fullscreen flag is reset on the window."]
    #[doc = " Unfortunately, this causes Android life cycle events that mess up"]
    #[doc = " several NativeActivity codebases like Stratum and UE4, so this"]
    #[doc = " flag should only be set for specific applications."]
    #[doc = " Use \"adb shell dumpsys SurfaceFlinger\" to verify"]
    #[doc = " that there is only one HWC next to the FB_TARGET."]
    VRAPI_MODE_FLAG_RESET_WINDOW_FULLSCREEN = 65280,
    #[doc = " The WindowSurface passed in is an ANativeWindow."]
    VRAPI_MODE_FLAG_NATIVE_WINDOW = 65536,
    #[doc = " Create the front buffer in TrustZone memory to allow protected DRM"]
    #[doc = " content to be rendered to the front buffer. This functionality"]
    #[doc = " requires the WindowSurface to be allocated from TimeWarp, via"]
    #[doc = " specifying the nativeWindow via VRAPI_MODE_FLAG_NATIVE_WINDOW."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_PROTECTED = 131072,
    #[doc = " Create a front buffer using the sRGB color space."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_SRGB = 524288,
    #[doc = " If set, indicates the OpenGL ES Context was created with EGL_CONTEXT_OPENGL_NO_ERROR_KHR"]
    #[doc = " attribute. The same attribute would be applied when TimeWrap creates the shared context."]
    #[doc = " More information could be found at:"]
    #[doc = " https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_create_context_no_error.txt"]
    VRAPI_MODE_FLAG_CREATE_CONTEXT_NO_ERROR = 1048576,
}
#[doc = " \\note the first two flags use the first two bytes for backwards compatibility on little endian"]
#[doc = " systems."]
pub use self::ovrModeFlags_ as ovrModeFlags;
#[doc = " Configuration details that stay constant between a vrapi_EnterVrMode()/vrapi_LeaveVrMode() pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrModeParms_ {
    pub Type: ovrStructureType,
    #[doc = " Combination of ovrModeFlags flags."]
    pub Flags: ::std::os::raw::c_uint,
    #[doc = " The Java VM is needed for the time warp thread to create a Java environment."]
    #[doc = " A Java environment is needed to access various system services. The thread"]
    #[doc = " that enters VR mode is responsible for attaching and detaching the Java"]
    #[doc = " environment. The Java Activity object is needed to get the windowManager,"]
    #[doc = " packageName, systemService, etc."]
    pub Java: ovrJava,
    #[doc = " Display to use for asynchronous time warp rendering."]
    #[doc = " Using EGL this is an EGLDisplay."]
    pub Display: ::std::os::raw::c_ulonglong,
    #[doc = " The ANativeWIndow associated with the application's Surface (requires"]
    #[doc = " VRAPI_MODE_FLAG_NATIVE_WINDOW). The ANativeWIndow is used for asynchronous time warp"]
    #[doc = " rendering."]
    pub WindowSurface: ::std::os::raw::c_ulonglong,
    #[doc = " The resources from this context will be shared with the asynchronous time warp."]
    #[doc = " Using EGL this is an EGLContext."]
    pub ShareContext: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrModeParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrModeParms_>(),
        56usize,
        concat!("Size of: ", stringify!(ovrModeParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrModeParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrModeParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Java as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Java)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Display as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).WindowSurface as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(WindowSurface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).ShareContext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(ShareContext)
        )
    );
}
#[doc = " Configuration details that stay constant between a vrapi_EnterVrMode()/vrapi_LeaveVrMode() pair."]
pub type ovrModeParms = ovrModeParms_;
#[doc = " Vulkan-specific mode paramaters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrModeParmsVulkan_ {
    pub ModeParms: ovrModeParms,
    #[doc = " For Vulkan, this should be the VkQueue created on the same Device as specified"]
    #[doc = " by vrapi_CreateSystemVulkan. An internally created VkFence object will be signaled"]
    #[doc = " by the completion of commands on the queue."]
    pub SynchronizationQueue: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrModeParmsVulkan_() {
    assert_eq!(
        ::std::mem::size_of::<ovrModeParmsVulkan_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrModeParmsVulkan_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrModeParmsVulkan_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrModeParmsVulkan_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParmsVulkan_>())).ModeParms as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParmsVulkan_),
            "::",
            stringify!(ModeParms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrModeParmsVulkan_>())).SynchronizationQueue as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParmsVulkan_),
            "::",
            stringify!(SynchronizationQueue)
        )
    );
}
#[doc = " Vulkan-specific mode paramaters."]
pub type ovrModeParmsVulkan = ovrModeParmsVulkan_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMobile {
    _unused: [u8; 0],
}
#[doc = " Full rigid body pose with first and second derivatives."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrRigidBodyPosef_ {
    pub Pose: ovrPosef,
    pub AngularVelocity: ovrVector3f,
    pub LinearVelocity: ovrVector3f,
    pub AngularAcceleration: ovrVector3f,
    pub LinearAcceleration: ovrVector3f,
    pub dead16: [::std::os::raw::c_uchar; 4usize],
    pub TimeInSeconds: f64,
    pub PredictionInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrRigidBodyPosef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrRigidBodyPosef_>(),
        96usize,
        concat!("Size of: ", stringify!(ovrRigidBodyPosef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrRigidBodyPosef_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrRigidBodyPosef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).Pose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).AngularVelocity as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(AngularVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).LinearVelocity as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(LinearVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).AngularAcceleration as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(AngularAcceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).LinearAcceleration as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(LinearAcceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).dead16 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(dead16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).TimeInSeconds as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).PredictionInSeconds as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(PredictionInSeconds)
        )
    );
}
#[doc = " Full rigid body pose with first and second derivatives."]
pub type ovrRigidBodyPosef = ovrRigidBodyPosef_;
#[repr(i32)]
#[doc = " Bit flags describing the current status of sensor tracking."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrTrackingStatus_ {
    VRAPI_TRACKING_STATUS_ORIENTATION_TRACKED = 1,
    VRAPI_TRACKING_STATUS_POSITION_TRACKED = 2,
    VRAPI_TRACKING_STATUS_ORIENTATION_VALID = 4,
    VRAPI_TRACKING_STATUS_POSITION_VALID = 8,
    VRAPI_TRACKING_STATUS_HMD_CONNECTED = 128,
}
#[doc = " Bit flags describing the current status of sensor tracking."]
pub use self::ovrTrackingStatus_ as ovrTrackingStatus;
#[doc = " Tracking state at a given absolute time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrTracking2_ {
    #[doc = " Sensor status described by ovrTrackingStatus flags."]
    pub Status: ::std::os::raw::c_uint,
    pub dead18: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Predicted head configuration at the requested absolute time."]
    #[doc = " The pose describes the head orientation and center eye position."]
    pub HeadPose: ovrRigidBodyPosef,
    pub Eye: [ovrTracking2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTracking2___bindgen_ty_1 {
    pub ProjectionMatrix: ovrMatrix4f,
    pub ViewMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrTracking2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking2___bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(ovrTracking2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking2___bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrTracking2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTracking2___bindgen_ty_1>())).ProjectionMatrix as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2___bindgen_ty_1),
            "::",
            stringify!(ProjectionMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTracking2___bindgen_ty_1>())).ViewMatrix as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2___bindgen_ty_1),
            "::",
            stringify!(ViewMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrTracking2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking2_>(),
        360usize,
        concat!("Size of: ", stringify!(ovrTracking2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTracking2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).Status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).dead18 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(dead18)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).HeadPose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).Eye as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(Eye)
        )
    );
}
#[doc = " Tracking state at a given absolute time."]
pub type ovrTracking2 = ovrTracking2_;
#[doc = " Reports the status and pose of a motion tracker."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrTracking_ {
    #[doc = " Sensor status described by ovrTrackingStatus flags."]
    pub Status: ::std::os::raw::c_uint,
    pub dead20: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Predicted head configuration at the requested absolute time."]
    #[doc = " The pose describes the head orientation and center eye position."]
    pub HeadPose: ovrRigidBodyPosef,
}
#[test]
fn bindgen_test_layout_ovrTracking_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking_>(),
        104usize,
        concat!("Size of: ", stringify!(ovrTracking_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTracking_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).Status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).dead20 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(dead20)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).HeadPose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(HeadPose)
        )
    );
}
#[doc = " Reports the status and pose of a motion tracker."]
pub type ovrTracking = ovrTracking_;
#[repr(i32)]
#[doc = " Specifies a reference frame for motion tracking data."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrTrackingTransform_ {
    VRAPI_TRACKING_TRANSFORM_IDENTITY = 0,
    VRAPI_TRACKING_TRANSFORM_CURRENT = 1,
    VRAPI_TRACKING_TRANSFORM_SYSTEM_CENTER_EYE_LEVEL = 2,
    VRAPI_TRACKING_TRANSFORM_SYSTEM_CENTER_FLOOR_LEVEL = 3,
}
#[doc = " Specifies a reference frame for motion tracking data."]
pub use self::ovrTrackingTransform_ as ovrTrackingTransform;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrTrackingSpace_ {
    VRAPI_TRACKING_SPACE_LOCAL = 0,
    VRAPI_TRACKING_SPACE_LOCAL_FLOOR = 1,
    VRAPI_TRACKING_SPACE_LOCAL_TILTED = 2,
    VRAPI_TRACKING_SPACE_STAGE = 3,
    VRAPI_TRACKING_SPACE_LOCAL_FIXED_YAW = 7,
}
pub use self::ovrTrackingSpace_ as ovrTrackingSpace;
#[repr(i32)]
#[doc = " Tracked device type id used to simplify interaction checks with Guardian"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrTrackedDeviceTypeId_ {
    VRAPI_TRACKED_DEVICE_NONE = -1,
    VRAPI_TRACKED_DEVICE_HMD = 0,
    VRAPI_TRACKED_DEVICE_HAND_LEFT = 1,
    VRAPI_TRACKED_DEVICE_HAND_RIGHT = 2,
    VRAPI_NUM_TRACKED_DEVICES = 3,
}
#[doc = " Tracked device type id used to simplify interaction checks with Guardian"]
pub use self::ovrTrackedDeviceTypeId_ as ovrTrackedDeviceTypeId;
#[doc = " Guardian boundary trigger state information based on a given tracked device type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrBoundaryTriggerResult_ {
    #[doc = " Closest point on the boundary surface."]
    pub ClosestPoint: ovrVector3f,
    #[doc = " Normal of the closest point on the boundary surface."]
    pub ClosestPointNormal: ovrVector3f,
    #[doc = " Distance to the closest guardian boundary surface."]
    pub ClosestDistance: f32,
    #[doc = " True if the boundary system is being triggered. Note that due to fade in/out effects this"]
    #[doc = " may not exactly match visibility."]
    pub IsTriggering: bool,
}
#[test]
fn bindgen_test_layout_ovrBoundaryTriggerResult_() {
    assert_eq!(
        ::std::mem::size_of::<ovrBoundaryTriggerResult_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrBoundaryTriggerResult_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrBoundaryTriggerResult_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrBoundaryTriggerResult_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestPoint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestPointNormal as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestPointNormal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestDistance as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).IsTriggering as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(IsTriggering)
        )
    );
}
#[doc = " Guardian boundary trigger state information based on a given tracked device type"]
pub type ovrBoundaryTriggerResult = ovrBoundaryTriggerResult_;
#[repr(i32)]
#[doc = " A texture type, such as 2D, array, or cubemap."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrTextureType_ {
    VRAPI_TEXTURE_TYPE_2D = 0,
    VRAPI_TEXTURE_TYPE_2D_ARRAY = 2,
    VRAPI_TEXTURE_TYPE_CUBE = 3,
    VRAPI_TEXTURE_TYPE_MAX = 4,
}
#[doc = " A texture type, such as 2D, array, or cubemap."]
pub use self::ovrTextureType_ as ovrTextureType;
#[repr(i32)]
#[doc = " A texture format."]
#[doc = " DEPRECATED in favor of passing platform-specific formats to vrapi_CreateTextureSwapChain3."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrTextureFormat_ {
    VRAPI_TEXTURE_FORMAT_NONE = 0,
    VRAPI_TEXTURE_FORMAT_565 = 1,
    VRAPI_TEXTURE_FORMAT_5551 = 2,
    VRAPI_TEXTURE_FORMAT_4444 = 3,
    VRAPI_TEXTURE_FORMAT_8888 = 4,
    VRAPI_TEXTURE_FORMAT_8888_sRGB = 5,
    VRAPI_TEXTURE_FORMAT_RGBA16F = 6,
    VRAPI_TEXTURE_FORMAT_DEPTH_16 = 7,
    VRAPI_TEXTURE_FORMAT_DEPTH_24 = 8,
    VRAPI_TEXTURE_FORMAT_DEPTH_24_STENCIL_8 = 9,
    VRAPI_TEXTURE_FORMAT_RG16 = 10,
}
#[doc = " A texture format."]
#[doc = " DEPRECATED in favor of passing platform-specific formats to vrapi_CreateTextureSwapChain3."]
pub use self::ovrTextureFormat_ as ovrTextureFormat;
#[repr(i32)]
#[doc = " Built-in convenience swapchains."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrDefaultTextureSwapChain_ {
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN = 1,
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN_LOADING_ICON = 2,
}
#[doc = " Built-in convenience swapchains."]
pub use self::ovrDefaultTextureSwapChain_ as ovrDefaultTextureSwapChain;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTextureSwapChain {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrSwapChainCreateFlags_ {
    #[doc = " Image is in subsampled layout."]
    VRAPI_SWAPCHAIN_CREATE_SUBSAMPLED_BIT = 1,
}
pub use self::ovrSwapChainCreateFlags_ as ovrSwapChainCreateFlags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrSwapChainUsageFlags_ {
    #[doc = " Image may be a color rendering target."]
    VRAPI_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT = 1,
    #[doc = " Image may be a depth/stencil rendering target."]
    VRAPI_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 2,
}
pub use self::ovrSwapChainUsageFlags_ as ovrSwapChainUsageFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrSwapChainCreateInfo_ {
    #[doc = " GL/Vulkan format of the texture, e.g. GL_RGBA or VK_FORMAT_R8G8B8A8_UNORM),"]
    #[doc = " depending on GraphicsAPI used."]
    pub Format: i64,
    #[doc = " Width in pixels."]
    pub Width: ::std::os::raw::c_int,
    #[doc = " Height in pixels."]
    pub Height: ::std::os::raw::c_int,
    #[doc = " The number of levels of detail available for minified sampling of the image."]
    pub Levels: ::std::os::raw::c_int,
    #[doc = " Number of faces, which can be either 6 (for cubemaps) or 1."]
    pub FaceCount: ::std::os::raw::c_int,
    #[doc = " Number of array layers, 1 for 2D texture, 2 for texture 2D array (multiview case)."]
    pub ArraySize: ::std::os::raw::c_int,
    #[doc = " Number of buffers in the texture swap chain."]
    pub BufferCount: ::std::os::raw::c_int,
    #[doc = " A bitmask of ovrSwapChainCreateFlags describing additional properties of"]
    #[doc = " the swapchain."]
    pub CreateFlags: u64,
    #[doc = " A bitmask of ovrSwapChainUsageFlags describing intended usage of the"]
    #[doc = " swapchain's images."]
    pub UsageFlags: u64,
}
#[test]
fn bindgen_test_layout_ovrSwapChainCreateInfo_() {
    assert_eq!(
        ::std::mem::size_of::<ovrSwapChainCreateInfo_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrSwapChainCreateInfo_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrSwapChainCreateInfo_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrSwapChainCreateInfo_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).Format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).Width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).Height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).Levels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(Levels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).FaceCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(FaceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).ArraySize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(ArraySize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).BufferCount as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(BufferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).CreateFlags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(CreateFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSwapChainCreateInfo_>())).UsageFlags as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSwapChainCreateInfo_),
            "::",
            stringify!(UsageFlags)
        )
    );
}
pub type ovrSwapChainCreateInfo = ovrSwapChainCreateInfo_;
#[repr(i32)]
#[doc = " Per-frame configuration options."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrFrameFlags_ {
    #[doc = " Flush the warp swap pipeline so the images show up immediately."]
    #[doc = " This is expensive and should only be used when an immediate transition"]
    #[doc = " is needed like displaying black when resetting the HMD orientation."]
    VRAPI_FRAME_FLAG_FLUSH = 2,
    #[doc = " This is the final frame. Do not accept any more frames after this."]
    VRAPI_FRAME_FLAG_FINAL = 4,
    #[doc = " Don't show the volume layer when set."]
    VRAPI_FRAME_FLAG_INHIBIT_VOLUME_LAYER = 64,
}
#[doc = " Per-frame configuration options."]
pub use self::ovrFrameFlags_ as ovrFrameFlags;
#[repr(i32)]
#[doc = " Per-frame configuration options that apply to a particular layer."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrFrameLayerFlags_ {
    #[doc = " NOTE: On Oculus standalone devices, chromatic aberration correction is enabled"]
    #[doc = " by default."]
    #[doc = " For non Oculus standalone devices, this must be explicitly enabled by specifying the layer"]
    #[doc = " flag as it is a quality / performance trade off."]
    VRAPI_FRAME_LAYER_FLAG_CHROMATIC_ABERRATION_CORRECTION = 2,
    #[doc = " Used for some HUDs, but generally considered bad practice."]
    VRAPI_FRAME_LAYER_FLAG_FIXED_TO_VIEW = 4,
    #[doc = " Spin the layer - for loading icons"]
    VRAPI_FRAME_LAYER_FLAG_SPIN = 8,
    #[doc = " Clip fragments outside the layer's TextureRect"]
    VRAPI_FRAME_LAYER_FLAG_CLIP_TO_TEXTURE_RECT = 16,
    #[doc = " To get gamma correct sRGB filtering of the eye textures, the textures must be"]
    #[doc = " allocated with GL_SRGB8_ALPHA8 format and the window surface must be allocated"]
    #[doc = " with these attributes:"]
    #[doc = " EGL_GL_COLORSPACE_KHR,  EGL_GL_COLORSPACE_SRGB_KHR"]
    #[doc = ""]
    #[doc = " While we can reallocate textures easily enough, we can't change the window"]
    #[doc = " colorspace without relaunching the entire application, so if you want to"]
    #[doc = " be able to toggle between gamma correct and incorrect, you must allocate"]
    #[doc = " the framebuffer as sRGB, then inhibit that processing when using normal"]
    #[doc = " textures."]
    #[doc = ""]
    #[doc = " If the texture being read isn't an sRGB texture, the conversion"]
    #[doc = " on write must be inhibited or the colors are washed out."]
    #[doc = " This is necessary for using external images on an sRGB framebuffer."]
    VRAPI_FRAME_LAYER_FLAG_INHIBIT_SRGB_FRAMEBUFFER = 256,
    #[doc = " Allow Layer to use an expensive filtering mode. Only useful for 2D layers that are high"]
    #[doc = " resolution (e.g. a remote desktop layer), typically double or more the target resolution."]
    VRAPI_FRAME_LAYER_FLAG_FILTER_EXPENSIVE = 524288,
}
#[doc = " Per-frame configuration options that apply to a particular layer."]
pub use self::ovrFrameLayerFlags_ as ovrFrameLayerFlags;
#[repr(i32)]
#[doc = " The user's eye (left or right) that can see a layer."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrFrameLayerEye_ {
    VRAPI_FRAME_LAYER_EYE_LEFT = 0,
    VRAPI_FRAME_LAYER_EYE_RIGHT = 1,
    VRAPI_FRAME_LAYER_EYE_MAX = 2,
}
#[doc = " The user's eye (left or right) that can see a layer."]
pub use self::ovrFrameLayerEye_ as ovrFrameLayerEye;
#[repr(i32)]
#[doc = " Selects an operation for alpha blending two images."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrFrameLayerBlend_ {
    VRAPI_FRAME_LAYER_BLEND_ZERO = 0,
    VRAPI_FRAME_LAYER_BLEND_ONE = 1,
    VRAPI_FRAME_LAYER_BLEND_SRC_ALPHA = 2,
    VRAPI_FRAME_LAYER_BLEND_ONE_MINUS_SRC_ALPHA = 5,
}
#[doc = " Selects an operation for alpha blending two images."]
pub use self::ovrFrameLayerBlend_ as ovrFrameLayerBlend;
#[repr(i32)]
#[doc = " Extra latency mode pipelines app CPU work a frame ahead of VR composition."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrExtraLatencyMode_ {
    VRAPI_EXTRA_LATENCY_MODE_OFF = 0,
    VRAPI_EXTRA_LATENCY_MODE_ON = 1,
    VRAPI_EXTRA_LATENCY_MODE_DYNAMIC = 2,
}
#[doc = " Extra latency mode pipelines app CPU work a frame ahead of VR composition."]
pub use self::ovrExtraLatencyMode_ as ovrExtraLatencyMode;
#[repr(i32)]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrFrameLayerType_ {
    VRAPI_FRAME_LAYER_TYPE_MAX = 4,
}
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub use self::ovrFrameLayerType_ as ovrFrameLayerType;
#[doc = " A compositor layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameLayerTexture_ {
    #[doc = " Because OpenGL ES does not support clampToBorder, it is the"]
    #[doc = " application's responsibility to make sure that all mip levels"]
    #[doc = " of the primary eye texture have a black border that will show"]
    #[doc = " up when time warp pushes the texture partially off screen."]
    pub ColorTextureSwapChain: *mut ovrTextureSwapChain,
    #[doc = " \\deprecated The depth texture is optional for positional time warp."]
    pub DepthTextureSwapChain: *mut ovrTextureSwapChain,
    #[doc = " Index to the texture from the set that should be displayed."]
    pub TextureSwapChainIndex: ::std::os::raw::c_int,
    #[doc = " Points on the screen are mapped by a distortion correction"]
    #[doc = " function into ( TanX, TanY, -1, 1 ) vectors that are transformed"]
    #[doc = " by this matrix to get ( S, T, Q, _ ) vectors that are looked"]
    #[doc = " up with texture2dproj() to get texels."]
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    #[doc = " Only texels within this range should be drawn."]
    #[doc = " This is a sub-rectangle of the [(0,0)-(1,1)] texture coordinate range."]
    pub TextureRect: ovrRectf,
    pub dead25: [::std::os::raw::c_uchar; 4usize],
    #[doc = " The tracking state for which ModelViewMatrix is correct."]
    #[doc = " It is ok to update the orientation for each eye, which"]
    #[doc = " can help minimize black edge pull-in, but the position"]
    #[doc = " must remain the same for both eyes, or the position would"]
    #[doc = " seem to judder \"backwards in time\" if a frame is dropped."]
    pub HeadPose: ovrRigidBodyPosef,
    #[doc = " \\unused parameter."]
    pub Pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_ovrFrameLayerTexture_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameLayerTexture_>(),
        208usize,
        concat!("Size of: ", stringify!(ovrFrameLayerTexture_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameLayerTexture_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameLayerTexture_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).ColorTextureSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(ColorTextureSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).DepthTextureSwapChain as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(DepthTextureSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TextureSwapChainIndex as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TextureSwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TexCoordsFromTanAngles as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TextureRect as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).dead25 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(dead25)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).HeadPose as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).Pad as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(Pad)
        )
    );
}
#[doc = " A compositor layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameLayerTexture = ovrFrameLayerTexture_;
#[doc = " Per-frame state of a compositor layer."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameLayer_ {
    #[doc = " Image used for each eye."]
    pub Textures: [ovrFrameLayerTexture; 2usize],
    #[doc = " Speed and scale of rotation when VRAPI_FRAME_LAYER_FLAG_SPIN is set in ovrFrameLayer::Flags"]
    pub SpinSpeed: f32,
    pub SpinScale: f32,
    #[doc = " Color scale for this layer (including alpha)"]
    pub ColorScale: f32,
    pub dead28: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Layer blend function."]
    pub SrcBlend: ovrFrameLayerBlend,
    pub DstBlend: ovrFrameLayerBlend,
    #[doc = " Combination of ovrFrameLayerFlags flags."]
    pub Flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrFrameLayer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameLayer_>(),
        448usize,
        concat!("Size of: ", stringify!(ovrFrameLayer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameLayer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameLayer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).Textures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(Textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SpinSpeed as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SpinSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SpinScale as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SpinScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).ColorScale as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(ColorScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).dead28 as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(dead28)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SrcBlend as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SrcBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).DstBlend as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(DstBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).Flags as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(Flags)
        )
    );
}
#[doc = " Per-frame state of a compositor layer."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameLayer = ovrFrameLayer_;
#[doc = " Configuration parameters that affect system performance and scheduling behavior."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPerformanceParms_ {
    #[doc = " These are fixed clock levels in the range [0, 3]."]
    pub CpuLevel: ::std::os::raw::c_int,
    pub GpuLevel: ::std::os::raw::c_int,
    #[doc = " These threads will get SCHED_FIFO."]
    pub MainThreadTid: ::std::os::raw::c_int,
    pub RenderThreadTid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrPerformanceParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPerformanceParms_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrPerformanceParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPerformanceParms_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPerformanceParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerformanceParms_>())).CpuLevel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(CpuLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerformanceParms_>())).GpuLevel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(GpuLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerformanceParms_>())).MainThreadTid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(MainThreadTid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerformanceParms_>())).RenderThreadTid as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(RenderThreadTid)
        )
    );
}
#[doc = " Configuration parameters that affect system performance and scheduling behavior."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrPerformanceParms = ovrPerformanceParms_;
#[doc = " Per-frame details."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameParms_ {
    pub Type: ovrStructureType,
    pub dead32: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Layers composited in the time warp."]
    pub Layers: [ovrFrameLayer; 4usize],
    pub LayerCount: ::std::os::raw::c_int,
    #[doc = " Combination of ovrFrameFlags flags."]
    pub Flags: ::std::os::raw::c_int,
    #[doc = " Application controlled frame index that uniquely identifies this particular frame."]
    #[doc = " This must be the same frame index that was passed to vrapi_GetPredictedDisplayTime()"]
    #[doc = " when synthesis of this frame started."]
    pub FrameIndex: ::std::os::raw::c_longlong,
    #[doc = " WarpSwap will not return until at least this many V-syncs have"]
    #[doc = " passed since the previous WarpSwap returned."]
    #[doc = " Setting to 2 will reduce power consumption and may make animation"]
    #[doc = " more regular for applications that can't hold full frame rate."]
    pub SwapInterval: ::std::os::raw::c_int,
    #[doc = " Latency Mode."]
    pub ExtraLatencyMode: ovrExtraLatencyMode,
    #[doc = " \\unused parameter."]
    pub Reserved: ovrMatrix4f,
    #[doc = " \\unused parameter."]
    pub Reserved1: *mut ::std::os::raw::c_void,
    #[doc = " CPU/GPU performance parameters."]
    pub PerformanceParms: ovrPerformanceParms,
    #[doc = " For handling HMD events and power level state changes."]
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrFrameParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameParms_>(),
        1936usize,
        concat!("Size of: ", stringify!(ovrFrameParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).dead32 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(dead32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Layers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).LayerCount as *const _ as usize },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(LayerCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Flags as *const _ as usize },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).FrameIndex as *const _ as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(FrameIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).SwapInterval as *const _ as usize },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(SwapInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).ExtraLatencyMode as *const _ as usize },
        1820usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(ExtraLatencyMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Reserved as *const _ as usize },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Reserved1 as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).PerformanceParms as *const _ as usize },
        1896usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(PerformanceParms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Java as *const _ as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Java)
        )
    );
}
#[doc = " Per-frame details."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameParms = ovrFrameParms_;
#[repr(i32)]
#[doc = " A layer type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrLayerType2_ {
    VRAPI_LAYER_TYPE_PROJECTION2 = 1,
    VRAPI_LAYER_TYPE_CYLINDER2 = 3,
    VRAPI_LAYER_TYPE_CUBE2 = 4,
    VRAPI_LAYER_TYPE_EQUIRECT2 = 5,
    VRAPI_LAYER_TYPE_LOADING_ICON2 = 6,
    VRAPI_LAYER_TYPE_FISHEYE2 = 7,
    VRAPI_LAYER_TYPE_EQUIRECT3 = 10,
}
#[doc = " A layer type."]
pub use self::ovrLayerType2_ as ovrLayerType2;
#[doc = " Properties shared by any type of layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerHeader2_ {
    pub Type: ovrLayerType2,
    #[doc = " Combination of ovrFrameLayerFlags flags."]
    pub Flags: u32,
    pub ColorScale: ovrVector4f,
    pub SrcBlend: ovrFrameLayerBlend,
    pub DstBlend: ovrFrameLayerBlend,
    #[doc = " \\unused parameter."]
    pub Reserved: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ovrLayerHeader2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerHeader2_>(),
        40usize,
        concat!("Size of: ", stringify!(ovrLayerHeader2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerHeader2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerHeader2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).ColorScale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(ColorScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).SrcBlend as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(SrcBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).DstBlend as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(DstBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " Properties shared by any type of layer."]
pub type ovrLayerHeader2 = ovrLayerHeader2_;
#[doc = " ovrLayerProjection2 provides support for a typical world view layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerProjection2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_PROJECTION2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerProjection2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerProjection2___bindgen_ty_1 {
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
}
#[test]
fn bindgen_test_layout_ovrLayerProjection2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerProjection2___bindgen_ty_1>(),
        96usize,
        concat!("Size of: ", stringify!(ovrLayerProjection2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerProjection2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerProjection2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).ColorSwapChain
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).SwapChainIndex
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).TexCoordsFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerProjection2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerProjection2_>(),
        328usize,
        concat!("Size of: ", stringify!(ovrLayerProjection2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerProjection2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerProjection2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerProjection2 provides support for a typical world view layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
pub type ovrLayerProjection2 = ovrLayerProjection2_;
#[doc = " ovrLayerCylinder2 provides support for a single 2D texture projected onto a cylinder shape."]
#[doc = ""]
#[doc = " For Cylinder, the vertex coordinates will be transformed as if the texture type was CUBE."]
#[doc = " Additionally, the interpolated vec3 will be remapped to vec2 by a direction-to-hemicyl mapping."]
#[doc = " This mapping is currently hard-coded to 180 degrees around and 60 degrees vertical FOV."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the"]
#[doc = " matrix will typically be the identity matrix (ie no scale, bias). In the stereo case, when the"]
#[doc = " image source comes from a single image, the transform is necessary to map the [0.0,1.0] output"]
#[doc = " to a different (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the"]
#[doc = " specified extents. No guarantees are made about whether fragments will be shaded outside the"]
#[doc = " rect, so it is important that the subrect have a transparent border."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCylinder2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_CYLINDER2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerCylinder2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerCylinder2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a 2D target (VRAPI_TEXTURE_TYPE_2D_*)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    #[doc = " \\note textureMatrix is set up like the following:"]
    #[doc = " sx,  0, tx, 0"]
    #[doc = " 0,  sy, ty, 0"]
    #[doc = "\t0,   0,  1, 0"]
    #[doc = "\t0,   0,  0, 1"]
    #[doc = " since we do not need z coord for mapping to 2d texture."]
    pub TextureMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrLayerCylinder2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCylinder2___bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(ovrLayerCylinder2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCylinder2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TexCoordsFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerCylinder2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCylinder2_>(),
        456usize,
        concat!("Size of: ", stringify!(ovrLayerCylinder2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCylinder2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCylinder2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerCylinder2 provides support for a single 2D texture projected onto a cylinder shape."]
#[doc = ""]
#[doc = " For Cylinder, the vertex coordinates will be transformed as if the texture type was CUBE."]
#[doc = " Additionally, the interpolated vec3 will be remapped to vec2 by a direction-to-hemicyl mapping."]
#[doc = " This mapping is currently hard-coded to 180 degrees around and 60 degrees vertical FOV."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the"]
#[doc = " matrix will typically be the identity matrix (ie no scale, bias). In the stereo case, when the"]
#[doc = " image source comes from a single image, the transform is necessary to map the [0.0,1.0] output"]
#[doc = " to a different (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the"]
#[doc = " specified extents. No guarantees are made about whether fragments will be shaded outside the"]
#[doc = " rect, so it is important that the subrect have a transparent border."]
#[doc = ""]
pub type ovrLayerCylinder2 = ovrLayerCylinder2_;
#[doc = " ovrLayerCube2 provides support for a single timewarped cubemap at infinity"]
#[doc = " with optional Offset vector (provided in normalized [-1.0,1.0] space)."]
#[doc = ""]
#[doc = " Cube maps are an omni-directional layer source that are directly supported"]
#[doc = " by the graphics hardware. The nature of the cube map definition results in"]
#[doc = " higher resolution (in pixels per solid angle) at the corners and edges of"]
#[doc = " the cube and lower resolution at the center of each face. While the cube map"]
#[doc = " does have variability in sample density, the variability is spread symmetrically"]
#[doc = " around the sphere."]
#[doc = ""]
#[doc = " Sometimes it is valuable to have an omni-directional format that has a"]
#[doc = " directional bias where quality and sample density is better in a particular"]
#[doc = " direction or over a particular region. If we changed the cube map sampling"]
#[doc = ""]
#[doc = " from:"]
#[doc = "   color = texture( cubeLayerSampler, direction );"]
#[doc = " to:"]
#[doc = "   color = texture( cubeLayerSampler, normalize( direction ) + offset );"]
#[doc = ""]
#[doc = " we can provide a remapping of the cube map sample distribution such that"]
#[doc = " samples in the \"offset\" direction map to a smaller region of the cube map"]
#[doc = " (and are thus higher resolution)."]
#[doc = ""]
#[doc = " A normal high resolution cube map can be resampled using the inverse of this"]
#[doc = " mapping to retain high resolution for one direction while signficantly reducing"]
#[doc = " the required size of the cube map."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCube2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_CUBE2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub Offset: ovrVector3f,
    pub Textures: [ovrLayerCube2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerCube2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a cube target"]
    #[doc = " (VRAPI_TEXTURE_TYPE_CUBE)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrLayerCube2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCube2___bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ovrLayerCube2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCube2___bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCube2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerCube2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCube2_>(),
        248usize,
        concat!("Size of: ", stringify!(ovrLayerCube2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCube2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCube2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2_>())).TexCoordsFromTanAngles as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Offset as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Textures as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerCube2 provides support for a single timewarped cubemap at infinity"]
#[doc = " with optional Offset vector (provided in normalized [-1.0,1.0] space)."]
#[doc = ""]
#[doc = " Cube maps are an omni-directional layer source that are directly supported"]
#[doc = " by the graphics hardware. The nature of the cube map definition results in"]
#[doc = " higher resolution (in pixels per solid angle) at the corners and edges of"]
#[doc = " the cube and lower resolution at the center of each face. While the cube map"]
#[doc = " does have variability in sample density, the variability is spread symmetrically"]
#[doc = " around the sphere."]
#[doc = ""]
#[doc = " Sometimes it is valuable to have an omni-directional format that has a"]
#[doc = " directional bias where quality and sample density is better in a particular"]
#[doc = " direction or over a particular region. If we changed the cube map sampling"]
#[doc = ""]
#[doc = " from:"]
#[doc = "   color = texture( cubeLayerSampler, direction );"]
#[doc = " to:"]
#[doc = "   color = texture( cubeLayerSampler, normalize( direction ) + offset );"]
#[doc = ""]
#[doc = " we can provide a remapping of the cube map sample distribution such that"]
#[doc = " samples in the \"offset\" direction map to a smaller region of the cube map"]
#[doc = " (and are thus higher resolution)."]
#[doc = ""]
#[doc = " A normal high resolution cube map can be resampled using the inverse of this"]
#[doc = " mapping to retain high resolution for one direction while signficantly reducing"]
#[doc = " the required size of the cube map."]
#[doc = ""]
pub type ovrLayerCube2 = ovrLayerCube2_;
#[doc = " ovrLayerEquirect2 provides support for a single Equirectangular texture at infinity."]
#[doc = ""]
#[doc = " For Equirectangular, the vertex coordinates will be transformed as if the texture type was CUBE,"]
#[doc = " and in the fragment shader, the interpolated vec3 will be remapped to vec2 by a"]
#[doc = " direction-to-equirect mapping."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the"]
#[doc = " matrix will typically be the identity matrix (ie no scale, bias). In the stereo case, when the"]
#[doc = " image source come from a single image, the transform is necessary to map the [0.0,1.0] output to"]
#[doc = " a different (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the"]
#[doc = " specified extents. No guarantees are made about whether fragments will be shaded outside the"]
#[doc = " rect, so it is important that the subrect have a transparent border."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEquirect2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_EQUIRECT2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub Textures: [ovrLayerEquirect2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerEquirect2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a 2D target (VRAPI_TEXTURE_TYPE_2D_*)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TextureRect: ovrRectf,
    #[doc = " \\note textureMatrix is set up like the following:"]
    #[doc = "\tsx,  0, tx, 0"]
    #[doc = "\t0,  sy, ty, 0"]
    #[doc = "\t0,   0,  1, 0"]
    #[doc = "\t0,   0,  0, 1"]
    #[doc = " since we do not need z coord for mapping to 2d texture."]
    pub TextureMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect2___bindgen_ty_1>(),
        96usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect2_>(),
        392usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEquirect2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2_>())).TexCoordsFromTanAngles as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).Textures as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerEquirect2 provides support for a single Equirectangular texture at infinity."]
#[doc = ""]
#[doc = " For Equirectangular, the vertex coordinates will be transformed as if the texture type was CUBE,"]
#[doc = " and in the fragment shader, the interpolated vec3 will be remapped to vec2 by a"]
#[doc = " direction-to-equirect mapping."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the"]
#[doc = " matrix will typically be the identity matrix (ie no scale, bias). In the stereo case, when the"]
#[doc = " image source come from a single image, the transform is necessary to map the [0.0,1.0] output to"]
#[doc = " a different (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the"]
#[doc = " specified extents. No guarantees are made about whether fragments will be shaded outside the"]
#[doc = " rect, so it is important that the subrect have a transparent border."]
#[doc = ""]
pub type ovrLayerEquirect2 = ovrLayerEquirect2_;
#[doc = " ovrLayerEquirect3 provides support for a single Equirectangular texture at infinity or"]
#[doc = " with non-infinite radius at a specific location."]
#[doc = ""]
#[doc = " This layer is very similar to ovrLayerEquirect2; the main difference is that it allows"]
#[doc = " for the specification of TexCoordsFromTanAngles per-eye as well as a translation"]
#[doc = " (in meters) which is applied to the equirect's center and radius (in meters)."]
#[doc = ""]
#[doc = " TexCoordsFromTanAngles.M[3][0..2] represent the translation of the equirect's center;"]
#[doc = " TexCoordsFromTanAngles.M[3][3] represents the radius of the equirect layer in meters"]
#[doc = " (0.0f is used for the infinite radius)."]
#[doc = " An example of setting the local equrect layer at 2 meters in front of the viewer with the"]
#[doc = " radius 1.5 meters is as follows:"]
#[doc = ""]
#[doc = "    ovrLayerEquirect3 layer = vrapi_DefaultLayerEquirect3();"]
#[doc = ""]
#[doc = "    const float radius = 1.5; // 1.5 m radius"]
#[doc = "    layer.HeadPose = tracking->HeadPose;"]
#[doc = "    ovrPosef pose = {};"]
#[doc = "    pose.Position.x = 0.0f;"]
#[doc = "    pose.Position.y = 0.0f;"]
#[doc = "    pose.Position.z = -2.0f;"]
#[doc = "    pose.Orientation.x = 0.0f;"]
#[doc = "    pose.Orientation.y = 0.0f;"]
#[doc = "    pose.Orientation.z = 0.0f;"]
#[doc = "    pose.Orientation.w = 1.0f;"]
#[doc = ""]
#[doc = "    const ovrMatrix4f poseM = vrapi_GetTransformFromPose(&pose);"]
#[doc = ""]
#[doc = "    for (int eye = 0; eye < VRAPI_FRAME_LAYER_EYE_MAX; eye++) {"]
#[doc = "        const ovrMatrix4f modelViewMatrix ="]
#[doc = "            ovrMatrix4f_Multiply(&tracking->Eye[eye].ViewMatrix, &poseM);"]
#[doc = "        ovrMatrix4f tex_coords_matrix = ovrMatrix4f_Inverse(&modelViewMatrix);"]
#[doc = "        tex_coords_matrix.M[3][3] = radius;"]
#[doc = "        layer.Textures[eye].TexCoordsFromTanAngles = tex_coords_matrix;"]
#[doc = "        ...."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEquirect3_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_EQUIRECT3."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerEquirect3___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerEquirect3___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a 2D target (VRAPI_TEXTURE_TYPE_2D_*)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    #[doc = " \\note textureMatrix is set up like the following:"]
    #[doc = "\tsx,  0, tx, 0"]
    #[doc = "\t0,  sy, ty, 0"]
    #[doc = "\t0,   0,  1, 0"]
    #[doc = "\t0,   0,  0, 1"]
    #[doc = " since we do not need z coord for mapping to 2d texture."]
    pub TextureMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect3___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect3___bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect3___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect3___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerEquirect3___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect3___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect3___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect3___bindgen_ty_1>())).TexCoordsFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3___bindgen_ty_1),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect3___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect3___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect3_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect3_>(),
        456usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect3_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect3_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEquirect3_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect3_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect3_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect3_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect3_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerEquirect3 provides support for a single Equirectangular texture at infinity or"]
#[doc = " with non-infinite radius at a specific location."]
#[doc = ""]
#[doc = " This layer is very similar to ovrLayerEquirect2; the main difference is that it allows"]
#[doc = " for the specification of TexCoordsFromTanAngles per-eye as well as a translation"]
#[doc = " (in meters) which is applied to the equirect's center and radius (in meters)."]
#[doc = ""]
#[doc = " TexCoordsFromTanAngles.M[3][0..2] represent the translation of the equirect's center;"]
#[doc = " TexCoordsFromTanAngles.M[3][3] represents the radius of the equirect layer in meters"]
#[doc = " (0.0f is used for the infinite radius)."]
#[doc = " An example of setting the local equrect layer at 2 meters in front of the viewer with the"]
#[doc = " radius 1.5 meters is as follows:"]
#[doc = ""]
#[doc = "    ovrLayerEquirect3 layer = vrapi_DefaultLayerEquirect3();"]
#[doc = ""]
#[doc = "    const float radius = 1.5; // 1.5 m radius"]
#[doc = "    layer.HeadPose = tracking->HeadPose;"]
#[doc = "    ovrPosef pose = {};"]
#[doc = "    pose.Position.x = 0.0f;"]
#[doc = "    pose.Position.y = 0.0f;"]
#[doc = "    pose.Position.z = -2.0f;"]
#[doc = "    pose.Orientation.x = 0.0f;"]
#[doc = "    pose.Orientation.y = 0.0f;"]
#[doc = "    pose.Orientation.z = 0.0f;"]
#[doc = "    pose.Orientation.w = 1.0f;"]
#[doc = ""]
#[doc = "    const ovrMatrix4f poseM = vrapi_GetTransformFromPose(&pose);"]
#[doc = ""]
#[doc = "    for (int eye = 0; eye < VRAPI_FRAME_LAYER_EYE_MAX; eye++) {"]
#[doc = "        const ovrMatrix4f modelViewMatrix ="]
#[doc = "            ovrMatrix4f_Multiply(&tracking->Eye[eye].ViewMatrix, &poseM);"]
#[doc = "        ovrMatrix4f tex_coords_matrix = ovrMatrix4f_Inverse(&modelViewMatrix);"]
#[doc = "        tex_coords_matrix.M[3][3] = radius;"]
#[doc = "        layer.Textures[eye].TexCoordsFromTanAngles = tex_coords_matrix;"]
#[doc = "        ...."]
pub type ovrLayerEquirect3 = ovrLayerEquirect3_;
#[doc = " ovrLayerLoadingIcon2 provides support for a monoscopic spinning layer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerLoadingIcon2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_LOADING_ICON2."]
    pub Header: ovrLayerHeader2,
    pub SpinSpeed: f32,
    pub SpinScale: f32,
    #[doc = " Only monoscopic texture supported for spinning layer."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrLayerLoadingIcon2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerLoadingIcon2_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrLayerLoadingIcon2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerLoadingIcon2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerLoadingIcon2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SpinSpeed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SpinSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SpinScale as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SpinScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).ColorSwapChain as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SwapChainIndex as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SwapChainIndex)
        )
    );
}
#[doc = " ovrLayerLoadingIcon2 provides support for a monoscopic spinning layer."]
#[doc = ""]
pub type ovrLayerLoadingIcon2 = ovrLayerLoadingIcon2_;
#[doc = " An \"equiangular fisheye\" or \"f-theta\" lens can be used to capture photos or video"]
#[doc = " of around 180 degrees without stitching."]
#[doc = ""]
#[doc = " The cameras probably aren't exactly vertical, so a transformation may need to be applied"]
#[doc = " before performing the fisheye calculation."]
#[doc = " A stereo fisheye camera rig will usually have slight misalignments between the two"]
#[doc = " cameras, so they need independent transformations."]
#[doc = ""]
#[doc = " Once in lens space, the ray is transformed into an ideal fisheye projection, where the"]
#[doc = " 180 degree hemisphere is mapped to a -1 to 1 2D space."]
#[doc = ""]
#[doc = " From there it can be mapped into actual texture coordinates, possibly two to an image for"]
#[doc = " stereo."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerFishEye2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_FISHEYE2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerFishEye2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerFishEye2___bindgen_ty_1 {
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub LensFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    pub TextureMatrix: ovrMatrix4f,
    pub Distortion: ovrVector4f,
}
#[test]
fn bindgen_test_layout_ovrLayerFishEye2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerFishEye2___bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(ovrLayerFishEye2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerFishEye2___bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerFishEye2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).LensFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(LensFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).Distortion as *const _
                as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(Distortion)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerFishEye2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerFishEye2_>(),
        488usize,
        concat!("Size of: ", stringify!(ovrLayerFishEye2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerFishEye2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerFishEye2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " An \"equiangular fisheye\" or \"f-theta\" lens can be used to capture photos or video"]
#[doc = " of around 180 degrees without stitching."]
#[doc = ""]
#[doc = " The cameras probably aren't exactly vertical, so a transformation may need to be applied"]
#[doc = " before performing the fisheye calculation."]
#[doc = " A stereo fisheye camera rig will usually have slight misalignments between the two"]
#[doc = " cameras, so they need independent transformations."]
#[doc = ""]
#[doc = " Once in lens space, the ray is transformed into an ideal fisheye projection, where the"]
#[doc = " 180 degree hemisphere is mapped to a -1 to 1 2D space."]
#[doc = ""]
#[doc = " From there it can be mapped into actual texture coordinates, possibly two to an image for"]
#[doc = " stereo."]
#[doc = ""]
pub type ovrLayerFishEye2 = ovrLayerFishEye2_;
#[doc = " Union that combines ovrLayer types in a way that allows them"]
#[doc = " to be used in a polymorphic way."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrLayer_Union2_ {
    pub Header: ovrLayerHeader2,
    pub Projection: ovrLayerProjection2,
    pub Cylinder: ovrLayerCylinder2,
    pub Cube: ovrLayerCube2,
    pub Equirect: ovrLayerEquirect2,
    pub Equirect3: ovrLayerEquirect3,
    pub LoadingIcon: ovrLayerLoadingIcon2,
    pub FishEye: ovrLayerFishEye2,
    _bindgen_union_align: [u64; 61usize],
}
#[test]
fn bindgen_test_layout_ovrLayer_Union2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayer_Union2_>(),
        488usize,
        concat!("Size of: ", stringify!(ovrLayer_Union2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayer_Union2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayer_Union2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Projection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Projection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Cylinder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Cylinder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Cube as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Cube)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Equirect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Equirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Equirect3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Equirect3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).LoadingIcon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(LoadingIcon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).FishEye as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(FishEye)
        )
    );
}
#[doc = " Union that combines ovrLayer types in a way that allows them"]
#[doc = " to be used in a polymorphic way."]
pub type ovrLayer_Union2 = ovrLayer_Union2_;
#[doc = " Parameters for frame submission."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrSubmitFrameDescription2_ {
    pub Flags: u32,
    pub SwapInterval: u32,
    pub FrameIndex: u64,
    pub DisplayTime: f64,
    #[doc = " \\unused parameter."]
    pub Pad: [::std::os::raw::c_uchar; 8usize],
    pub LayerCount: u32,
    pub Layers: *const *const ovrLayerHeader2,
}
#[test]
fn bindgen_test_layout_ovrSubmitFrameDescription2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrSubmitFrameDescription2_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrSubmitFrameDescription2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrSubmitFrameDescription2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrSubmitFrameDescription2_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).SwapInterval as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(SwapInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).FrameIndex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(FrameIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).DisplayTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(DisplayTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Pad as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).LayerCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(LayerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Layers as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Layers)
        )
    );
}
#[doc = " Parameters for frame submission."]
pub type ovrSubmitFrameDescription2 = ovrSubmitFrameDescription2_;
#[repr(i32)]
#[doc = " Identifies a VR-related application thread."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrPerfThreadType_ {
    VRAPI_PERF_THREAD_TYPE_MAIN = 0,
    VRAPI_PERF_THREAD_TYPE_RENDERER = 1,
}
#[doc = " Identifies a VR-related application thread."]
pub use self::ovrPerfThreadType_ as ovrPerfThreadType;
#[repr(i32)]
#[doc = " Color space types for HMDs"]
#[doc = ""]
#[doc = " Until vrapi_SetClientColorDesc is called, the client will default to Rec2020 for Quest and"]
#[doc = " Rec709 for Go HMDs."]
#[doc = ""]
#[doc = " This API only handles color-space remapping. Unless specified, all color spaces use D65 white"]
#[doc = " point. It will not affect brightness, contrast or gamma curves. Some of these aspects such as"]
#[doc = " gamma, is handled by the texture format being used. From the GPU samplers' point-of-view, each"]
#[doc = " texture will continue to be treated as linear luminance including sRGB which is converted to"]
#[doc = " linear by the texture sampler."]
#[doc = ""]
#[doc = " 'VRAPI_COLORSPACE_UNMANAGED' will force the runtime to skip color correction for the provided"]
#[doc = " content. This is *not* recommended unless the app developer is sure about what they're doing."]
#[doc = " 'VRAPI_COLORSPACE_UNMANAGED' is mostly useful for research & experimentation, but not for"]
#[doc = " software distribution. This is because unless the client is applying the necessary corrections"]
#[doc = " for each HMD type, the results seen in the HMD will be uncalibrated. This is especially true for"]
#[doc = " future HMDs where the color space is not yet known or defined, which could lead to colors that"]
#[doc = " look too dull, too saturated, or hue shifted."]
#[doc = ""]
#[doc = " Although native Quest and Rift CV1 color spaces are provided as options, they are not"]
#[doc = " standardized color spaces. While we provide the exact color space primary coordinates, for"]
#[doc = " better standardized visualized of authored content, it's recommended that the developers master"]
#[doc = " using a well-defined color space in the provided in the options such as Rec.2020."]
#[doc = ""]
#[doc = " It is also recommended that content be authored for the wider color spaces instead of Rec.709 to"]
#[doc = " prevent visuals from looking \"washed out\", \"dull\" or \"desaturated\" on wider gamut devices like"]
#[doc = " the Quest."]
#[doc = ""]
#[doc = " Unique Color Space Details with Chromaticity Primaries in CIE 1931 xy:"]
#[doc = ""]
#[doc = " Color Space: P3, similar to DCI-P3, but using D65 white point instead."]
#[doc = " Red  : (0.680, 0.320)"]
#[doc = " Green: (0.265, 0.690)"]
#[doc = " Blue : (0.150, 0.060)"]
#[doc = " White: (0.313, 0.329)"]
#[doc = ""]
#[doc = " Color Space: Rift CV1 between P3 & Adobe RGB using D75 white point"]
#[doc = " Red  : (0.666, 0.334)"]
#[doc = " Green: (0.238, 0.714)"]
#[doc = " Blue : (0.139, 0.053)"]
#[doc = " White: (0.298, 0.318)"]
#[doc = ""]
#[doc = " Color Space: Quest similar to Rift CV1 using D75 white point"]
#[doc = " Red  : (0.661, 0.338)"]
#[doc = " Green: (0.228, 0.718)"]
#[doc = " Blue : (0.142, 0.042)"]
#[doc = " White: (0.298, 0.318)"]
#[doc = ""]
#[doc = " Color Space: Rift S similar to Rec 709 using D75"]
#[doc = " Red  : (0.640, 0.330)"]
#[doc = " Green: (0.292, 0.586)"]
#[doc = " Blue : (0.156, 0.058)"]
#[doc = " White: (0.298, 0.318)"]
#[doc = ""]
#[doc = " Note: Due to LCD limitations, the Go display will not be able to meaningfully differentiate"]
#[doc = " brightness levels below 13 out of 255 for 8-bit sRGB or 0.0015 out of 1.0 max for linear-RGB"]
#[doc = " shader output values. To that end, it is recommended that reliance on a dark and narrow gamut is"]
#[doc = " avoided, and the content is instead spread across a larger brightness range when possible."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrColorSpace_ {
    #[doc = " No color correction, not recommended for production use. See notes above for more info"]
    VRAPI_COLORSPACE_UNMANAGED = 0,
    #[doc = " Preferred color space for standardized color across all Oculus HMDs with D65 white point"]
    VRAPI_COLORSPACE_REC_2020 = 1,
    #[doc = " Rec. 709 is used on Oculus Go and shares the same primary color coordinates as sRGB"]
    VRAPI_COLORSPACE_REC_709 = 2,
    #[doc = " Oculus Rift CV1 uses a unique color space, see enum description for more info"]
    VRAPI_COLORSPACE_RIFT_CV1 = 3,
    #[doc = " Oculus Rift S uses a unique color space, see enum description for more info"]
    VRAPI_COLORSPACE_RIFT_S = 4,
    #[doc = " Oculus Quest's native color space is slightly different than Rift CV1"]
    VRAPI_COLORSPACE_QUEST = 5,
    #[doc = " Similar to DCI-P3. See notes above for more details on P3"]
    VRAPI_COLORSPACE_P3 = 6,
    #[doc = " Similar to sRGB but with deeper greens using D65 white point"]
    VRAPI_COLORSPACE_ADOBE_RGB = 7,
}
#[doc = " Color space types for HMDs"]
#[doc = ""]
#[doc = " Until vrapi_SetClientColorDesc is called, the client will default to Rec2020 for Quest and"]
#[doc = " Rec709 for Go HMDs."]
#[doc = ""]
#[doc = " This API only handles color-space remapping. Unless specified, all color spaces use D65 white"]
#[doc = " point. It will not affect brightness, contrast or gamma curves. Some of these aspects such as"]
#[doc = " gamma, is handled by the texture format being used. From the GPU samplers' point-of-view, each"]
#[doc = " texture will continue to be treated as linear luminance including sRGB which is converted to"]
#[doc = " linear by the texture sampler."]
#[doc = ""]
#[doc = " 'VRAPI_COLORSPACE_UNMANAGED' will force the runtime to skip color correction for the provided"]
#[doc = " content. This is *not* recommended unless the app developer is sure about what they're doing."]
#[doc = " 'VRAPI_COLORSPACE_UNMANAGED' is mostly useful for research & experimentation, but not for"]
#[doc = " software distribution. This is because unless the client is applying the necessary corrections"]
#[doc = " for each HMD type, the results seen in the HMD will be uncalibrated. This is especially true for"]
#[doc = " future HMDs where the color space is not yet known or defined, which could lead to colors that"]
#[doc = " look too dull, too saturated, or hue shifted."]
#[doc = ""]
#[doc = " Although native Quest and Rift CV1 color spaces are provided as options, they are not"]
#[doc = " standardized color spaces. While we provide the exact color space primary coordinates, for"]
#[doc = " better standardized visualized of authored content, it's recommended that the developers master"]
#[doc = " using a well-defined color space in the provided in the options such as Rec.2020."]
#[doc = ""]
#[doc = " It is also recommended that content be authored for the wider color spaces instead of Rec.709 to"]
#[doc = " prevent visuals from looking \"washed out\", \"dull\" or \"desaturated\" on wider gamut devices like"]
#[doc = " the Quest."]
#[doc = ""]
#[doc = " Unique Color Space Details with Chromaticity Primaries in CIE 1931 xy:"]
#[doc = ""]
#[doc = " Color Space: P3, similar to DCI-P3, but using D65 white point instead."]
#[doc = " Red  : (0.680, 0.320)"]
#[doc = " Green: (0.265, 0.690)"]
#[doc = " Blue : (0.150, 0.060)"]
#[doc = " White: (0.313, 0.329)"]
#[doc = ""]
#[doc = " Color Space: Rift CV1 between P3 & Adobe RGB using D75 white point"]
#[doc = " Red  : (0.666, 0.334)"]
#[doc = " Green: (0.238, 0.714)"]
#[doc = " Blue : (0.139, 0.053)"]
#[doc = " White: (0.298, 0.318)"]
#[doc = ""]
#[doc = " Color Space: Quest similar to Rift CV1 using D75 white point"]
#[doc = " Red  : (0.661, 0.338)"]
#[doc = " Green: (0.228, 0.718)"]
#[doc = " Blue : (0.142, 0.042)"]
#[doc = " White: (0.298, 0.318)"]
#[doc = ""]
#[doc = " Color Space: Rift S similar to Rec 709 using D75"]
#[doc = " Red  : (0.640, 0.330)"]
#[doc = " Green: (0.292, 0.586)"]
#[doc = " Blue : (0.156, 0.058)"]
#[doc = " White: (0.298, 0.318)"]
#[doc = ""]
#[doc = " Note: Due to LCD limitations, the Go display will not be able to meaningfully differentiate"]
#[doc = " brightness levels below 13 out of 255 for 8-bit sRGB or 0.0015 out of 1.0 max for linear-RGB"]
#[doc = " shader output values. To that end, it is recommended that reliance on a dark and narrow gamut is"]
#[doc = " avoided, and the content is instead spread across a larger brightness range when possible."]
#[doc = ""]
pub use self::ovrColorSpace_ as ovrColorSpace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHmdColorDesc_ {
    #[doc = " See ovrColorSpace for more info."]
    pub ColorSpace: ovrColorSpace,
    pub dead53: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_ovrHmdColorDesc_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHmdColorDesc_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrHmdColorDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHmdColorDesc_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrHmdColorDesc_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdColorDesc_>())).ColorSpace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdColorDesc_),
            "::",
            stringify!(ColorSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHmdColorDesc_>())).dead53 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHmdColorDesc_),
            "::",
            stringify!(dead53)
        )
    );
}
pub type ovrHmdColorDesc = ovrHmdColorDesc_;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrEventType_ {
    VRAPI_EVENT_NONE = 0,
    VRAPI_EVENT_DATA_LOST = 1,
    VRAPI_EVENT_VISIBILITY_GAINED = 2,
    VRAPI_EVENT_VISIBILITY_LOST = 3,
    VRAPI_EVENT_FOCUS_GAINED = 4,
    VRAPI_EVENT_FOCUS_LOST = 5,
    VRAPI_EVENT_DISPLAY_REFRESH_RATE_CHANGE = 11,
}
pub use self::ovrEventType_ as ovrEventType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEventHeader_ {
    pub EventType: ovrEventType,
}
#[test]
fn bindgen_test_layout_ovrEventHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventHeader_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrEventHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventHeader_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEventHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEventHeader_>())).EventType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventHeader_),
            "::",
            stringify!(EventType)
        )
    );
}
pub type ovrEventHeader = ovrEventHeader_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEventDataLost_ {
    pub EventHeader: ovrEventHeader,
}
#[test]
fn bindgen_test_layout_ovrEventDataLost_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventDataLost_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrEventDataLost_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventDataLost_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEventDataLost_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEventDataLost_>())).EventHeader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventDataLost_),
            "::",
            stringify!(EventHeader)
        )
    );
}
pub type ovrEventDataLost = ovrEventDataLost_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEventVisibilityGained_ {
    pub EventHeader: ovrEventHeader,
}
#[test]
fn bindgen_test_layout_ovrEventVisibilityGained_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventVisibilityGained_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrEventVisibilityGained_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventVisibilityGained_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEventVisibilityGained_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEventVisibilityGained_>())).EventHeader as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventVisibilityGained_),
            "::",
            stringify!(EventHeader)
        )
    );
}
pub type ovrEventVisibilityGained = ovrEventVisibilityGained_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEventVisibilityLost_ {
    pub EventHeader: ovrEventHeader,
}
#[test]
fn bindgen_test_layout_ovrEventVisibilityLost_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventVisibilityLost_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrEventVisibilityLost_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventVisibilityLost_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEventVisibilityLost_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEventVisibilityLost_>())).EventHeader as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventVisibilityLost_),
            "::",
            stringify!(EventHeader)
        )
    );
}
pub type ovrEventVisibilityLost = ovrEventVisibilityLost_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEventFocusGained_ {
    pub EventHeader: ovrEventHeader,
}
#[test]
fn bindgen_test_layout_ovrEventFocusGained_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventFocusGained_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrEventFocusGained_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventFocusGained_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEventFocusGained_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEventFocusGained_>())).EventHeader as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventFocusGained_),
            "::",
            stringify!(EventHeader)
        )
    );
}
pub type ovrEventFocusGained = ovrEventFocusGained_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEventFocusLost_ {
    pub EventHeader: ovrEventHeader,
}
#[test]
fn bindgen_test_layout_ovrEventFocusLost_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventFocusLost_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrEventFocusLost_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventFocusLost_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEventFocusLost_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEventFocusLost_>())).EventHeader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventFocusLost_),
            "::",
            stringify!(EventHeader)
        )
    );
}
pub type ovrEventFocusLost = ovrEventFocusLost_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrEventDisplayRefreshRateChange_ {
    pub EventHeader: ovrEventHeader,
    pub fromDisplayRefreshRate: f32,
    pub toDisplayRefreshRate: f32,
}
#[test]
fn bindgen_test_layout_ovrEventDisplayRefreshRateChange_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventDisplayRefreshRateChange_>(),
        12usize,
        concat!("Size of: ", stringify!(ovrEventDisplayRefreshRateChange_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventDisplayRefreshRateChange_>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ovrEventDisplayRefreshRateChange_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEventDisplayRefreshRateChange_>())).EventHeader as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventDisplayRefreshRateChange_),
            "::",
            stringify!(EventHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEventDisplayRefreshRateChange_>())).fromDisplayRefreshRate
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventDisplayRefreshRateChange_),
            "::",
            stringify!(fromDisplayRefreshRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrEventDisplayRefreshRateChange_>())).toDisplayRefreshRate
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventDisplayRefreshRateChange_),
            "::",
            stringify!(toDisplayRefreshRate)
        )
    );
}
pub type ovrEventDisplayRefreshRateChange = ovrEventDisplayRefreshRateChange_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrEventDataBuffer_ {
    pub EventHeader: ovrEventHeader,
    pub EventData: [::std::os::raw::c_uchar; 4000usize],
}
#[test]
fn bindgen_test_layout_ovrEventDataBuffer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrEventDataBuffer_>(),
        4004usize,
        concat!("Size of: ", stringify!(ovrEventDataBuffer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrEventDataBuffer_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrEventDataBuffer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEventDataBuffer_>())).EventHeader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventDataBuffer_),
            "::",
            stringify!(EventHeader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrEventDataBuffer_>())).EventData as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrEventDataBuffer_),
            "::",
            stringify!(EventData)
        )
    );
}
pub type ovrEventDataBuffer = ovrEventDataBuffer_;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrEventSize_ {
    VRAPI_MAX_EVENT_SIZE = 4004,
}
pub use self::ovrEventSize_ as ovrEventSize;
extern "C" {
    #[doc = " Returns the version + compile time stamp as a string."]
    #[doc = " Can be called any time from any thread."]
    pub fn vrapi_GetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns global, absolute high-resolution time in seconds. This is the same value"]
    #[doc = " as used in sensor messages and on Android also the same as Java's system.nanoTime(),"]
    #[doc = " which is what the V-sync timestamp is based on."]
    #[doc = " \\warning Do not use this time as a seed for simulations, animations or other logic."]
    #[doc = " An animation, for instance, should not be updated based on the \"real time\" the"]
    #[doc = " animation code is executed. Instead, an animation should be updated based on the"]
    #[doc = " time it will be displayed. Using the \"real time\" will introduce intra-frame motion"]
    #[doc = " judder when the code is not executed at a consistent point in time every frame."]
    #[doc = " In other words, for simulations, animations and other logic use the time returned"]
    #[doc = " by vrapi_GetPredictedDisplayTime()."]
    #[doc = " Can be called any time from any thread."]
    pub fn vrapi_GetTimeInSeconds() -> f64;
}
extern "C" {
    #[doc = " Initializes the API for application use."]
    #[doc = " This is lightweight and does not create any threads."]
    #[doc = " This is typically called from onCreate() or shortly thereafter."]
    #[doc = " Can be called from any thread."]
    #[doc = " Returns a non-zero value from ovrInitializeStatus on error."]
    pub fn vrapi_Initialize(initParms: *const ovrInitParms) -> ovrInitializeStatus;
}
extern "C" {
    #[doc = " Shuts down the API on application exit."]
    #[doc = " This is typically called from onDestroy() or shortly thereafter."]
    #[doc = " Can be called from any thread."]
    pub fn vrapi_Shutdown();
}
extern "C" {
    #[doc = " Returns a VrApi property."]
    #[doc = " These functions can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_SetPropertyInt(
        java: *const ovrJava,
        propType: ovrProperty,
        intVal: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vrapi_SetPropertyFloat(java: *const ovrJava, propType: ovrProperty, floatVal: f32);
}
extern "C" {
    #[doc = " Returns false if the property cannot be read."]
    pub fn vrapi_GetPropertyInt(
        java: *const ovrJava,
        propType: ovrProperty,
        intVal: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns a system property. These are constants for a particular device."]
    #[doc = " These functions can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_GetSystemPropertyInt(
        java: *const ovrJava,
        propType: ovrSystemProperty,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyFloat(java: *const ovrJava, propType: ovrSystemProperty) -> f32;
}
extern "C" {
    #[doc = " Returns the number of elements written to values array."]
    pub fn vrapi_GetSystemPropertyFloatArray(
        java: *const ovrJava,
        propType: ovrSystemProperty,
        values: *mut f32,
        numArrayValues: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyInt64Array(
        java: *const ovrJava,
        propType: ovrSystemProperty,
        values: *mut i64,
        numArrayValues: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The return memory is guaranteed to be valid until the next call to"]
    #[doc = " vrapi_GetSystemPropertyString."]
    pub fn vrapi_GetSystemPropertyString(
        java: *const ovrJava,
        propType: ovrSystemProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a system status. These are variables that may change at run-time."]
    #[doc = " This function can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_GetSystemStatusInt(
        java: *const ovrJava,
        statusType: ovrSystemStatus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemStatusFloat(java: *const ovrJava, statusType: ovrSystemStatus) -> f32;
}
extern "C" {
    #[doc = " Starts up the time warp, V-sync tracking, sensor reading, clock locking,"]
    #[doc = " thread scheduling, and sets video options. The parms are copied, and are"]
    #[doc = " not referenced after the function returns."]
    #[doc = ""]
    #[doc = " This should be called after vrapi_Initialize(), when the app is both"]
    #[doc = " resumed and has a valid window surface (ANativeWindow)."]
    #[doc = ""]
    #[doc = " On Android, an application cannot just allocate a new window surface"]
    #[doc = " and render to it. Android allocates and manages the window surface and"]
    #[doc = " (after the fact) notifies the application of the state of affairs through"]
    #[doc = " life cycle events (surfaceCreated / surfaceChanged / surfaceDestroyed)."]
    #[doc = " The application (or 3rd party engine) typically handles these events."]
    #[doc = " Since the VrApi cannot just allocate a new window surface, and the VrApi"]
    #[doc = " does not handle the life cycle events, the VrApi somehow has to take over"]
    #[doc = " ownership of the Android surface from the application. To allow this, the"]
    #[doc = " application can explicitly pass the EGLDisplay, EGLContext and EGLSurface"]
    #[doc = " or ANativeWindow to vrapi_EnterVrMode(). The EGLDisplay and EGLContext are"]
    #[doc = " used to create a shared context used by the background time warp thread."]
    #[doc = ""]
    #[doc = " If, however, the application does not explicitly pass in these objects, then"]
    #[doc = " vrapi_EnterVrMode() *must* be called from a thread with an OpenGL ES context"]
    #[doc = " current on the Android window surface. The context of the calling thread is"]
    #[doc = " then used to match the version and config for the context used by the background"]
    #[doc = " time warp thread. The time warp will also hijack the Android window surface"]
    #[doc = " from the context that is current on the calling thread. On return, the context"]
    #[doc = " from the calling thread will be current on an invisible pbuffer, because the"]
    #[doc = " time warp takes ownership of the Android window surface. Note that this requires"]
    #[doc = " the config used by the calling thread to have an EGL_SURFACE_TYPE with EGL_PBUFFER_BIT."]
    #[doc = ""]
    #[doc = " New applications must always explicitly pass in the EGLDisplay, EGLContext"]
    #[doc = " and ANativeWindow, otherwise vrapi_EnterVrMode will fail."]
    #[doc = ""]
    #[doc = " This function will return NULL when entering VR mode failed because the ANativeWindow"]
    #[doc = " was not valid. If the ANativeWindow's buffer queue is abandoned"]
    #[doc = " (\"BufferQueueProducer: BufferQueue has been abandoned\"), then the app can wait for a"]
    #[doc = " new ANativeWindow (through SurfaceCreated). If another API is already connected to"]
    #[doc = " the ANativeWindow (\"BufferQueueProducer: already connected\"), then the app has to first"]
    #[doc = " disconnect whatever is connected to the ANativeWindow (typically an EGLSurface)."]
    pub fn vrapi_EnterVrMode(parms: *const ovrModeParms) -> *mut ovrMobile;
}
extern "C" {
    #[doc = " Shut everything down for window destruction or when the activity is paused."]
    #[doc = " The ovrMobile object is freed by this function."]
    #[doc = ""]
    #[doc = " Must be called from the same thread that called vrapi_EnterVrMode(). If the"]
    #[doc = " application did not explicitly pass in the Android window surface, then this"]
    #[doc = " thread *must* have the same OpenGL ES context that was current on the Android"]
    #[doc = " window surface before calling vrapi_EnterVrMode(). By calling this function,"]
    #[doc = " the time warp gives up ownership of the Android window surface, and on return,"]
    #[doc = " the context from the calling thread will be current again on the Android window"]
    #[doc = " surface."]
    pub fn vrapi_LeaveVrMode(ovr: *mut ovrMobile);
}
extern "C" {
    #[doc = " Returns a predicted absolute system time in seconds at which the next set"]
    #[doc = " of eye images will be displayed."]
    #[doc = ""]
    #[doc = " The predicted time is the middle of the time period during which the new"]
    #[doc = " eye images will be displayed. The number of frames predicted ahead depends"]
    #[doc = " on the pipeline depth of the engine and the minumum number of V-syncs in"]
    #[doc = " between eye image rendering. The better the prediction, the less black will"]
    #[doc = " be pulled in at the edges by the time warp."]
    #[doc = ""]
    #[doc = " The frameIndex is an application controlled number that uniquely identifies"]
    #[doc = " the new set of eye images for which synthesis is about to start. This same"]
    #[doc = " frameIndex must be passed to vrapi_SubmitFrame*() when the new eye images are"]
    #[doc = " submitted to the time warp. The frameIndex is expected to be incremented"]
    #[doc = " once every frame before calling this function."]
    #[doc = ""]
    #[doc = " Can be called from any thread while in VR mode."]
    pub fn vrapi_GetPredictedDisplayTime(
        ovr: *mut ovrMobile,
        frameIndex: ::std::os::raw::c_longlong,
    ) -> f64;
}
extern "C" {
    #[doc = " Returns the predicted sensor state based on the specified absolute system time"]
    #[doc = " in seconds. Pass absTime value of 0.0 to request the most recent sensor reading."]
    #[doc = ""]
    #[doc = " Can be called from any thread while in VR mode."]
    pub fn vrapi_GetPredictedTracking2(ovr: *mut ovrMobile, absTimeInSeconds: f64) -> ovrTracking2;
}
extern "C" {
    pub fn vrapi_GetPredictedTracking(ovr: *mut ovrMobile, absTimeInSeconds: f64) -> ovrTracking;
}
extern "C" {
    pub fn vrapi_RecenterPose(ovr: *mut ovrMobile);
}
extern "C" {
    pub fn vrapi_GetTrackingTransform(
        ovr: *mut ovrMobile,
        whichTransform: ovrTrackingTransform,
    ) -> ovrPosef;
}
extern "C" {
    pub fn vrapi_SetTrackingTransform(ovr: *mut ovrMobile, pose: ovrPosef);
}
extern "C" {
    #[doc = " Returns the current tracking space"]
    pub fn vrapi_GetTrackingSpace(ovr: *mut ovrMobile) -> ovrTrackingSpace;
}
extern "C" {
    #[doc = " Set the tracking space. There are currently two options:"]
    #[doc = "   * VRAPI_TRACKING_SPACE_LOCAL (default)"]
    #[doc = "         The local tracking space's origin is at the nominal head position"]
    #[doc = "         with +y up, and -z forward. This space is volatile and will change"]
    #[doc = "         when system recentering occurs."]
    #[doc = "   * VRAPI_TRACKING_SPACE_LOCAL_FLOOR"]
    #[doc = "         The local floor tracking space is the same as the local tracking"]
    #[doc = "         space, except its origin is translated down to the floor. The local"]
    #[doc = "         floor space differs from the local space only in its y translation."]
    #[doc = "         This space is volatile and will change when system recentering occurs."]
    pub fn vrapi_SetTrackingSpace(ovr: *mut ovrMobile, whichSpace: ovrTrackingSpace) -> ovrResult;
}
extern "C" {
    #[doc = " Returns pose of the requested space relative to the current space."]
    #[doc = " The returned value is not affected by the current tracking transform."]
    pub fn vrapi_LocateTrackingSpace(ovr: *mut ovrMobile, target: ovrTrackingSpace) -> ovrPosef;
}
extern "C" {
    #[doc = " Get the geometry of the Guardian System as a list of points that define the outer boundary"]
    #[doc = " space. You can choose to get just the number of points by passing in a null value for points or"]
    #[doc = " by passing in a pointsCountInput size of 0.  Otherwise pointsCountInput will be used to fetch"]
    #[doc = " as many points as possible from the Guardian points data.  If the input size exceeds the"]
    #[doc = " number of points that are currently stored off we only copy up to the number of points that we"]
    #[doc = " have and pointsCountOutput will return the number of copied points"]
    pub fn vrapi_GetBoundaryGeometry(
        ovr: *mut ovrMobile,
        pointsCountInput: u32,
        pointsCountOutput: *mut u32,
        points: *mut ovrVector3f,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the dimension of the Oriented Bounding box for the Guardian System.  This is the largest"]
    #[doc = " fit rectangle within the Guardian System boundary geometry. The pose value contains the forward"]
    #[doc = " facing direction as well as the translation for the oriented box.  The scale return value"]
    #[doc = " returns a scalar value for the width, height, and depth of the box.  These values are half the"]
    #[doc = " actual size as they are scalars and in meters.\""]
    pub fn vrapi_GetBoundaryOrientedBoundingBox(
        ovr: *mut ovrMobile,
        pose: *mut ovrPosef,
        scale: *mut ovrVector3f,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of a 3D point against the Guardian System Boundary and returns whether"]
    #[doc = " or not a given point is inside or outside of the boundary.  If a more detailed set of boundary"]
    #[doc = " trigger information is requested a ovrBoundaryTriggerResult may be passed in.  However null may"]
    #[doc = " also be passed in to just return whether a point is inside the boundary or not."]
    pub fn vrapi_TestPointIsInBoundary(
        ovr: *mut ovrMobile,
        point: ovrVector3f,
        pointInsideBoundary: *mut bool,
        result: *mut ovrBoundaryTriggerResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of position tracked devices (e.g. HMD and/or Controllers) against the"]
    #[doc = " Guardian System boundary. This function returns an ovrGuardianTriggerResult which contains"]
    #[doc = " information such as distance and closest point based on collision/proximity test"]
    pub fn vrapi_GetBoundaryTriggerState(
        ovr: *mut ovrMobile,
        deviceId: ovrTrackedDeviceTypeId,
        result: *mut ovrBoundaryTriggerResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Used to force Guardian System mesh visibility to true.  Forcing to false will set the Guardian"]
    #[doc = " System back to normal operation."]
    pub fn vrapi_RequestBoundaryVisible(ovr: *mut ovrMobile, visible: bool) -> ovrResult;
}
extern "C" {
    #[doc = " Used to access whether or not the Guardian System is visible or not"]
    pub fn vrapi_GetBoundaryVisible(ovr: *mut ovrMobile, visible: *mut bool) -> ovrResult;
}
extern "C" {
    #[doc = " Create a texture swap chain that can be passed to vrapi_SubmitFrame*()."]
    #[doc = " Must be called from a thread with a valid OpenGL ES context current."]
    #[doc = ""]
    #[doc = " 'bufferCount' used to be a bool that selected either a single texture index"]
    #[doc = " or a triple buffered index, but the new entry point vrapi_CreateTextureSwapChain2,"]
    #[doc = " allows up to 16 buffers to be allocated, which is useful for maintaining a"]
    #[doc = " deep video buffer queue to get better frame timing."]
    #[doc = ""]
    #[doc = " 'format' used to be an ovrTextureFormat but has been expanded to accept"]
    #[doc = " platform specific format types. For GLES, this is the internal format."]
    #[doc = " If an unsupported format is provided, swapchain creation will fail."]
    #[doc = ""]
    #[doc = " SwapChain creation failures result in a return value of 'nullptr'."]
    pub fn vrapi_CreateTextureSwapChain4(
        createInfo: *const ovrSwapChainCreateInfo,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain3(
        type_: ovrTextureType,
        format: i64,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        bufferCount: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain2(
        type_: ovrTextureType,
        format: ovrTextureFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        bufferCount: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain(
        type_: ovrTextureType,
        format: ovrTextureFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        buffered: bool,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    #[doc = " Create an Android SurfaceTexture based texture swap chain suitable for use with"]
    #[doc = " vrapi_SubmitFrame*(). Updating of the SurfaceTexture is handled through normal Android platform"]
    #[doc = " specific mechanisms from within the Compositor. A reference to the Android Surface object"]
    #[doc = " associated with the SurfaceTexture may be obtained by calling"]
    #[doc = " vrapi_GetTextureSwapChainAndroidSurface."]
    #[doc = ""]
    #[doc = " An optional width and height (ie width and height do not equal zero) may be provided in order to"]
    #[doc = " set the default size of the image buffers. Note that the image producer may override the buffer"]
    #[doc = " size, in which case the default values provided here will not be used (ie both video"]
    #[doc = " decompression or camera preview override the size automatically)."]
    #[doc = ""]
    #[doc = " If isProtected is true, the surface swapchain will be created as a protected surface, ie for"]
    #[doc = " supporting secure video playback."]
    pub fn vrapi_CreateAndroidSurfaceSwapChain(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateAndroidSurfaceSwapChain2(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isProtected: bool,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    #[doc = " Destroy the given texture swap chain."]
    #[doc = " Must be called from a thread with the same OpenGL ES context current when"]
    #[doc = " vrapi_CreateTextureSwapChain was called."]
    pub fn vrapi_DestroyTextureSwapChain(chain: *mut ovrTextureSwapChain);
}
extern "C" {
    #[doc = " Returns the number of textures in the swap chain."]
    pub fn vrapi_GetTextureSwapChainLength(
        chain: *mut ovrTextureSwapChain,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the OpenGL name of the texture at the given index."]
    pub fn vrapi_GetTextureSwapChainHandle(
        chain: *mut ovrTextureSwapChain,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the Android Surface object associated with the swap chain."]
    pub fn vrapi_GetTextureSwapChainAndroidSurface(chain: *mut ovrTextureSwapChain) -> jobject;
}
extern "C" {
    #[doc = " Accepts new eye images plus poses that will be used for future warps."]
    #[doc = " The parms are copied, and are not referenced after the function returns."]
    #[doc = ""]
    #[doc = " This will block until the textures from the previous vrapi_SubmitFrame() have been"]
    #[doc = " consumed by the background thread, to allow one frame of overlap for maximum"]
    #[doc = " GPU utilization, while preventing multiple frames from piling up variable latency."]
    #[doc = ""]
    #[doc = " This will block until at least SwapInterval vsyncs have passed since the last"]
    #[doc = " call to vrapi_SubmitFrame*() to prevent applications with simple scenes from"]
    #[doc = " generating completely wasted frames."]
    #[doc = ""]
    #[doc = " IMPORTANT: any dynamic textures that are passed to vrapi_SubmitFrame*() must be"]
    #[doc = " triple buffered to avoid flickering and performance problems."]
    #[doc = ""]
    #[doc = " The VrApi allows for one frame of overlap which is essential on tiled mobile GPUs."]
    #[doc = " Because there is one frame of overlap, the eye images have typically not completed"]
    #[doc = " rendering by the time they are submitted to vrapi_SubmitFrame*(). To allow the time"]
    #[doc = " warp to check whether the eye images have completed rendering, vrapi_SubmitFrame*()"]
    #[doc = " adds a sync object to the current context. Therefore, vrapi_SubmitFrame*() *must*"]
    #[doc = " be called from a thread with an OpenGL ES context whose completion ensures that"]
    #[doc = " frame rendering is complete. Generally this is the thread and context that was used"]
    #[doc = " for the rendering."]
    pub fn vrapi_SubmitFrame(ovr: *mut ovrMobile, parms: *const ovrFrameParms);
}
extern "C" {
    #[doc = " vrapi_SubmitFrame2 takes a frameDescription describing per-frame information such as:"]
    #[doc = " a flexible list of layers which should be drawn this frame and a frame index."]
    pub fn vrapi_SubmitFrame2(
        ovr: *mut ovrMobile,
        frameDescription: *const ovrSubmitFrameDescription2,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Set the CPU and GPU performance levels."]
    #[doc = ""]
    #[doc = " Increasing the levels increases performance at the cost of higher power consumption"]
    #[doc = " which likely leads to a greater chance of overheating."]
    #[doc = ""]
    #[doc = " Levels will be clamped to the expected range. Default clock levels are cpuLevel = 2, gpuLevel"]
    #[doc = " = 2."]
    pub fn vrapi_SetClockLevels(ovr: *mut ovrMobile, cpuLevel: i32, gpuLevel: i32) -> ovrResult;
}
extern "C" {
    #[doc = " Specify which app threads should be given higher scheduling priority."]
    pub fn vrapi_SetPerfThread(
        ovr: *mut ovrMobile,
        type_: ovrPerfThreadType,
        threadId: u32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " If VRAPI_EXTRA_LATENCY_MODE_ON specified, adds an extra frame of latency for full GPU"]
    #[doc = " utilization. Default is VRAPI_EXTRA_LATENCY_MODE_OFF."]
    #[doc = ""]
    #[doc = " The latency mode specified will be applied on the next call to vrapi_SubmitFrame2()."]
    pub fn vrapi_SetExtraLatencyMode(ovr: *mut ovrMobile, mode: ovrExtraLatencyMode) -> ovrResult;
}
extern "C" {
    #[doc = " Returns native color space description of the current HMD. This is *not* a \"getter\" function"]
    #[doc = " for vrapi_SetClientColorDesc function. It will only return a fixed value for the current HMD."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrHmdColorDesc."]
    pub fn vrapi_GetHmdColorDesc(ovr: *mut ovrMobile) -> ovrHmdColorDesc;
}
extern "C" {
    #[doc = " Sets the color space actively being used by the client app."]
    #[doc = ""]
    #[doc = " This value does not have to follow the color space provided in ovr_GetHmdColorDesc. It should"]
    #[doc = " reflect the color space used in the final rendered frame the client has submitted to the SDK."]
    #[doc = " If this function is never called, the session will keep using the default color space deemed"]
    #[doc = " appropriate by the runtime. See remarks in ovrColorSpace enum for more info on default behavior."]
    #[doc = ""]
    #[doc = " \\return Returns an ovrResult indicating success or failure."]
    pub fn vrapi_SetClientColorDesc(
        ovr: *mut ovrMobile,
        colorDesc: *const ovrHmdColorDesc,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Set the Display Refresh Rate."]
    #[doc = " Returns ovrSuccess or an ovrError code."]
    #[doc = " Returns 'ovrError_InvalidParameter' if requested refresh rate is not supported by the device."]
    #[doc = " Returns 'ovrError_InvalidOperation' if the display refresh rate request was not allowed (such as"]
    #[doc = " when the device is in low power mode)."]
    pub fn vrapi_SetDisplayRefreshRate(ovr: *mut ovrMobile, refreshRate: f32) -> ovrResult;
}
extern "C" {
    #[doc = " Returns VrApi state information to the application."]
    #[doc = " The application should read from the VrApi event queue with regularity."]
    #[doc = ""]
    #[doc = " The caller must pass a pointer to memory that is at least the size of the largest event"]
    #[doc = " structure, VRAPI_LARGEST_EVENT_TYPE. On return, the structure is filled in with the current"]
    #[doc = " event's data. All event structures start with the ovrEventHeader, which contains the"]
    #[doc = " type of the event. Based on this type, the caller can cast the passed ovrEventHeader"]
    #[doc = " pointer to the appropriate event type."]
    #[doc = ""]
    #[doc = " Returns ovrSuccess if no error occured."]
    #[doc = " If no events are pending the event header EventType will be VRAPI_EVENT_NONE."]
    pub fn vrapi_PollEvent(event: *mut ovrEventHeader) -> ovrResult;
}
#[repr(i32)]
#[doc = " Describes button input types."]
#[doc = " For the Gear VR Controller and headset, only the following ovrButton types are reported to the"]
#[doc = " application:"]
#[doc = ""]
#[doc = " ovrButton_Back, ovrButton_A, ovrButton_Enter"]
#[doc = ""]
#[doc = " ovrButton_Home, ovrButton_VolUp, ovrButtonVolDown and ovrButton_Back are system buttons that are"]
#[doc = " never reported to applications. ovrButton_Back button has system-level handling for long"]
#[doc = " presses, but application-level handling for short-presses. Since a short-press is determined by"]
#[doc = " the time interval between down and up events, the ovrButton_Back flag is only set when the back"]
#[doc = " button comes up in less than the short-press time (0.25 seconds). The ovrButton_Back flag always"]
#[doc = " signals a short press and will only remain set for a single frame."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrButton_ {
    ovrButton_A = 1,
    ovrButton_B = 2,
    ovrButton_RThumb = 4,
    ovrButton_RShoulder = 8,
    ovrButton_X = 256,
    ovrButton_Y = 512,
    ovrButton_LThumb = 1024,
    ovrButton_LShoulder = 2048,
    ovrButton_Up = 65536,
    ovrButton_Down = 131072,
    ovrButton_Left = 262144,
    ovrButton_Right = 524288,
    ovrButton_Enter = 1048576,
    ovrButton_Back = 2097152,
    ovrButton_GripTrigger = 67108864,
    ovrButton_Trigger = 536870912,
    ovrButton_Joystick = -2147483648,
    ovrButton_EnumSize = 2147483647,
}
#[doc = " Describes button input types."]
#[doc = " For the Gear VR Controller and headset, only the following ovrButton types are reported to the"]
#[doc = " application:"]
#[doc = ""]
#[doc = " ovrButton_Back, ovrButton_A, ovrButton_Enter"]
#[doc = ""]
#[doc = " ovrButton_Home, ovrButton_VolUp, ovrButtonVolDown and ovrButton_Back are system buttons that are"]
#[doc = " never reported to applications. ovrButton_Back button has system-level handling for long"]
#[doc = " presses, but application-level handling for short-presses. Since a short-press is determined by"]
#[doc = " the time interval between down and up events, the ovrButton_Back flag is only set when the back"]
#[doc = " button comes up in less than the short-press time (0.25 seconds). The ovrButton_Back flag always"]
#[doc = " signals a short press and will only remain set for a single frame."]
pub use self::ovrButton_ as ovrButton;
#[repr(i32)]
#[doc = " Describes touch input types."]
#[doc = " These values map to capacitive touch values and derived pose states"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrTouch_ {
    ovrTouch_A = 1,
    ovrTouch_B = 2,
    ovrTouch_X = 4,
    ovrTouch_Y = 8,
    ovrTouch_TrackPad = 16,
    ovrTouch_Joystick = 32,
    ovrTouch_IndexTrigger = 64,
    ovrTouch_ThumbUp = 256,
    ovrTouch_IndexPointing = 512,
    ovrTouch_BaseState = 768,
    ovrTouch_LThumb = 1024,
    ovrTouch_RThumb = 2048,
    ovrTouch_ThumbRest = 4096,
    ovrTouch_LThumbRest = 8192,
    ovrTouch_RThumbRest = 16384,
    ovrTouch_EnumSize = 16385,
}
#[doc = " Describes touch input types."]
#[doc = " These values map to capacitive touch values and derived pose states"]
pub use self::ovrTouch_ as ovrTouch;
#[repr(i32)]
#[doc = " Specifies which controller is connected; multiple can be connected at once."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrControllerType_ {
    ovrControllerType_None = 0,
    ovrControllerType_Reserved0 = 1,
    ovrControllerType_Reserved1 = 2,
    ovrControllerType_TrackedRemote = 4,
    ovrControllerType_Gamepad = 16,
    ovrControllerType_Hand = 32,
    ovrControllerType_StandardPointer = 128,
    ovrControllerType_EnumSize = 2147483647,
}
#[doc = " Specifies which controller is connected; multiple can be connected at once."]
pub use self::ovrControllerType_ as ovrControllerType;
pub type ovrDeviceID = u32;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrDeviceIdType_ {
    ovrDeviceIdType_Invalid = 2147483647,
}
pub use self::ovrDeviceIdType_ as ovrDeviceIdType;
#[doc = " This header starts all ovrInputCapabilities structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputCapabilityHeader_ {
    pub Type: ovrControllerType,
    #[doc = " A unique ID for the input device"]
    pub DeviceID: ovrDeviceID,
}
#[test]
fn bindgen_test_layout_ovrInputCapabilityHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputCapabilityHeader_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrInputCapabilityHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputCapabilityHeader_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrInputCapabilityHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputCapabilityHeader_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputCapabilityHeader_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputCapabilityHeader_>())).DeviceID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputCapabilityHeader_),
            "::",
            stringify!(DeviceID)
        )
    );
}
#[doc = " This header starts all ovrInputCapabilities structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
pub type ovrInputCapabilityHeader = ovrInputCapabilityHeader_;
#[repr(i32)]
#[doc = " Specifies capabilites of a controller"]
#[doc = " Note that left and right hand are non-exclusive (a two-handed controller could set both)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrControllerCapabilities_ {
    ovrControllerCaps_HasOrientationTracking = 1,
    ovrControllerCaps_HasPositionTracking = 2,
    ovrControllerCaps_LeftHand = 4,
    ovrControllerCaps_RightHand = 8,
    ovrControllerCaps_ModelOculusGo = 16,
    ovrControllerCaps_HasAnalogIndexTrigger = 64,
    ovrControllerCaps_HasAnalogGripTrigger = 128,
    ovrControllerCaps_HasSimpleHapticVibration = 512,
    ovrControllerCaps_HasBufferedHapticVibration = 1024,
    ovrControllerCaps_ModelGearVR = 2048,
    ovrControllerCaps_HasTrackpad = 4096,
    ovrControllerCaps_HasJoystick = 8192,
    ovrControllerCaps_ModelOculusTouch = 16384,
    ovrControllerCaps_EnumSize = 2147483647,
}
#[doc = " Specifies capabilites of a controller"]
#[doc = " Note that left and right hand are non-exclusive (a two-handed controller could set both)"]
pub use self::ovrControllerCapabilities_ as ovrControllerCapabilities;
#[doc = " Details about the Oculus Remote input device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputTrackedRemoteCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Mask of button capabilities described by ovrButton"]
    pub ButtonCapabilities: u32,
    #[doc = " Maximum coordinates of the Trackpad, bottom right exclusive"]
    #[doc = " For a 300x200 Trackpad, return 299x199"]
    pub TrackpadMaxX: u16,
    pub TrackpadMaxY: u16,
    #[doc = " Size of the Trackpad in mm (millimeters)"]
    pub TrackpadSizeX: f32,
    pub TrackpadSizeY: f32,
    #[doc = " added in API version 1.1.13.0"]
    #[doc = " Maximum submittable samples for the haptics buffer"]
    pub HapticSamplesMax: u32,
    #[doc = " length in milliseconds of a sample in the haptics buffer."]
    pub HapticSampleDurationMS: u32,
    #[doc = " added in API version 1.1.15.0"]
    pub TouchCapabilities: u32,
    pub Reserved4: u32,
    pub Reserved5: u32,
}
#[test]
fn bindgen_test_layout_ovrInputTrackedRemoteCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputTrackedRemoteCapabilities_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrInputTrackedRemoteCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputTrackedRemoteCapabilities_>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ovrInputTrackedRemoteCapabilities_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).ButtonCapabilities
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadMaxX as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadMaxX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadMaxY as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadMaxY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).HapticSamplesMax
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(HapticSamplesMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).HapticSampleDurationMS
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(HapticSampleDurationMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TouchCapabilities
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TouchCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Reserved4 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Reserved5 as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Reserved5)
        )
    );
}
#[doc = " Details about the Oculus Remote input device."]
pub type ovrInputTrackedRemoteCapabilities = ovrInputTrackedRemoteCapabilities_;
#[doc = " Capabilities for an XBox style game pad"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputGamepadCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    pub ControllerCapabilities: u32,
    pub ButtonCapabilities: u32,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputGamepadCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputGamepadCapabilities_>(),
        176usize,
        concat!("Size of: ", stringify!(ovrInputGamepadCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputGamepadCapabilities_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputGamepadCapabilities_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).ButtonCapabilities as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).Reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type ovrInputGamepadCapabilities = ovrInputGamepadCapabilities_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStandardPointerCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Maximum submittable samples for the haptics buffer"]
    pub HapticSamplesMax: u32,
    #[doc = " length in milliseconds of a sample in the haptics buffer."]
    pub HapticSampleDurationMS: u32,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputStandardPointerCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStandardPointerCapabilities_>(),
        184usize,
        concat!(
            "Size of: ",
            stringify!(ovrInputStandardPointerCapabilities_)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStandardPointerCapabilities_>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrInputStandardPointerCapabilities_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStandardPointerCapabilities_>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStandardPointerCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStandardPointerCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStandardPointerCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStandardPointerCapabilities_>())).HapticSamplesMax
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStandardPointerCapabilities_),
            "::",
            stringify!(HapticSamplesMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStandardPointerCapabilities_>())).HapticSampleDurationMS
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStandardPointerCapabilities_),
            "::",
            stringify!(HapticSampleDurationMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStandardPointerCapabilities_>())).Reserved as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStandardPointerCapabilities_),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type ovrInputStandardPointerCapabilities = ovrInputStandardPointerCapabilities_;
#[doc = " The buffer data for playing haptics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHapticBuffer_ {
    #[doc = " Start time of the buffer"]
    pub BufferTime: f64,
    #[doc = " Number of samples in the buffer;"]
    pub NumSamples: u32,
    pub Terminated: bool,
    pub HapticBuffer: *mut u8,
}
#[test]
fn bindgen_test_layout_ovrHapticBuffer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHapticBuffer_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrHapticBuffer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHapticBuffer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHapticBuffer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).BufferTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(BufferTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).NumSamples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(NumSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).Terminated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(Terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).HapticBuffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(HapticBuffer)
        )
    );
}
#[doc = " The buffer data for playing haptics"]
pub type ovrHapticBuffer = ovrHapticBuffer_;
#[doc = " This header starts all ovrInputState structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateHeader_ {
    #[doc = " Type type of controller"]
    pub ControllerType: ovrControllerType,
    #[doc = " System time when the controller state was last updated."]
    pub TimeInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrInputStateHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateHeader_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrInputStateHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateHeader_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateHeader_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeader_>())).ControllerType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeader_),
            "::",
            stringify!(ControllerType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeader_>())).TimeInSeconds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeader_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
}
#[doc = " This header starts all ovrInputState structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
pub type ovrInputStateHeader = ovrInputStateHeader_;
#[doc = " ovrInputStateTrackedRemote describes the complete input state for the"]
#[doc = " orientation-tracked remote. The TrackpadPosition coordinates returned"]
#[doc = " for the GearVR Controller are in raw, absolute units."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateTrackedRemote_ {
    pub Header: ovrInputStateHeader,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: u32,
    #[doc = " Finger contact status for trackpad"]
    #[doc = " true = finger is on trackpad, false = finger is off trackpad"]
    pub TrackpadStatus: u32,
    #[doc = " X and Y coordinates of the Trackpad"]
    pub TrackpadPosition: ovrVector2f,
    #[doc = " The percentage of max battery charge remaining."]
    pub BatteryPercentRemaining: u8,
    #[doc = " Increments every time the remote is recentered. If this changes, the application may need"]
    #[doc = " to adjust its arm model accordingly."]
    pub RecenterCount: u8,
    #[doc = " Reserved for future use."]
    pub Reserved: u16,
    #[doc = " added in API version 1.1.13.0"]
    pub IndexTrigger: f32,
    pub GripTrigger: f32,
    #[doc = " added in API version 1.1.15.0"]
    pub Touches: u32,
    pub Reserved5a: u32,
    pub Joystick: ovrVector2f,
    pub JoystickNoDeadZone: ovrVector2f,
}
#[test]
fn bindgen_test_layout_ovrInputStateTrackedRemote_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateTrackedRemote_>(),
        72usize,
        concat!("Size of: ", stringify!(ovrInputStateTrackedRemote_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateTrackedRemote_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateTrackedRemote_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Buttons as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).TrackpadStatus as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(TrackpadStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).TrackpadPosition as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(TrackpadPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).BatteryPercentRemaining
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(BatteryPercentRemaining)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).RecenterCount as *const _
                as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(RecenterCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Reserved as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).IndexTrigger as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(IndexTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).GripTrigger as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(GripTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Touches as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Touches)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Reserved5a as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Reserved5a)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Joystick as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Joystick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).JoystickNoDeadZone as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(JoystickNoDeadZone)
        )
    );
}
#[doc = " ovrInputStateTrackedRemote describes the complete input state for the"]
#[doc = " orientation-tracked remote. The TrackpadPosition coordinates returned"]
#[doc = " for the GearVR Controller are in raw, absolute units."]
pub type ovrInputStateTrackedRemote = ovrInputStateTrackedRemote_;
#[doc = " ovrInputStateGamepad describes the input state gamepad input devices"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateGamepad_ {
    pub Header: ovrInputStateHeader,
    pub Buttons: u32,
    pub LeftTrigger: f32,
    pub RightTrigger: f32,
    pub LeftJoystick: ovrVector2f,
    pub RightJoystick: ovrVector2f,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputStateGamepad_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateGamepad_>(),
        208usize,
        concat!("Size of: ", stringify!(ovrInputStateGamepad_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateGamepad_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateGamepad_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Buttons as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).LeftTrigger as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(LeftTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).RightTrigger as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(RightTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).LeftJoystick as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(LeftJoystick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).RightJoystick as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(RightJoystick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Reserved as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type ovrInputStateGamepad = ovrInputStateGamepad_;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrInputStateStandardPointerStatus_ {
    ovrInputStateStandardPointerStatus_PointerValid = 2,
    ovrInputStateStandardPointerStatus_MenuPressed = 4,
}
pub use self::ovrInputStateStandardPointerStatus_ as ovrInputStateStandardPointerStatus;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrInputStateStandardPointer_ {
    pub Header: ovrInputStateHeader,
    pub PointerPose: ovrPosef,
    pub PointerStrength: f32,
    pub GripPose: ovrPosef,
    pub InputStateStatus: u32,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputStateStandardPointer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateStandardPointer_>(),
        240usize,
        concat!("Size of: ", stringify!(ovrInputStateStandardPointer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateStandardPointer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateStandardPointer_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateStandardPointer_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateStandardPointer_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateStandardPointer_>())).PointerPose as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateStandardPointer_),
            "::",
            stringify!(PointerPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateStandardPointer_>())).PointerStrength as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateStandardPointer_),
            "::",
            stringify!(PointerStrength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateStandardPointer_>())).GripPose as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateStandardPointer_),
            "::",
            stringify!(GripPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateStandardPointer_>())).InputStateStatus as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateStandardPointer_),
            "::",
            stringify!(InputStateStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateStandardPointer_>())).Reserved as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateStandardPointer_),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type ovrInputStateStandardPointer = ovrInputStateStandardPointer_;
#[repr(i32)]
#[doc = " Specifies left or right handedness."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandedness_ {
    VRAPI_HAND_UNKNOWN = 0,
    VRAPI_HAND_LEFT = 1,
    VRAPI_HAND_RIGHT = 2,
}
#[doc = " Specifies left or right handedness."]
pub use self::ovrHandedness_ as ovrHandedness;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandCapabilities_ {
    ovrHandCaps_LeftHand = 1,
    ovrHandCaps_RightHand = 2,
    ovrHandCaps_EnumSize = 2147483647,
}
pub use self::ovrHandCapabilities_ as ovrHandCapabilities;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandStateCapabilities_ {
    ovrHandStateCaps_PinchIndex = 1,
    ovrHandStateCaps_PinchMiddle = 2,
    ovrHandStateCaps_PinchRing = 4,
    ovrHandStateCaps_PinchPinky = 8,
    ovrHandStateCaps_EnumSize = 2147483647,
}
pub use self::ovrHandStateCapabilities_ as ovrHandStateCapabilities;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputHandCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    pub HandCapabilities: u32,
    pub StateCapabilities: u32,
}
#[test]
fn bindgen_test_layout_ovrInputHandCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputHandCapabilities_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrInputHandCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputHandCapabilities_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrInputHandCapabilities_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHandCapabilities_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHandCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHandCapabilities_>())).HandCapabilities as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHandCapabilities_),
            "::",
            stringify!(HandCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHandCapabilities_>())).StateCapabilities as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHandCapabilities_),
            "::",
            stringify!(StateCapabilities)
        )
    );
}
pub type ovrInputHandCapabilities = ovrInputHandCapabilities_;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandTrackingStatus_ {
    ovrHandTrackingStatus_Untracked = 0,
    ovrHandTrackingStatus_Tracked = 1,
    ovrHandTrackingStatus_EnumSize = 2147483647,
}
pub use self::ovrHandTrackingStatus_ as ovrHandTrackingStatus;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandFingers_ {
    ovrHandFinger_Thumb = 0,
    ovrHandFinger_Index = 1,
    ovrHandFinger_Middle = 2,
    ovrHandFinger_Ring = 3,
    ovrHandFinger_Pinky = 4,
    ovrHandFinger_Max = 5,
    ovrHandFinger_EnumSize = 2147483647,
}
pub use self::ovrHandFingers_ as ovrHandFingers;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandPinchStrength_ {
    ovrHandPinchStrength_Index = 0,
    ovrHandPinchStrength_Middle = 1,
    ovrHandPinchStrength_Ring = 2,
    ovrHandPinchStrength_Pinky = 3,
    ovrHandPinchStrength_Max = 4,
    ovrHandPinchStrength_EnumSize = 2147483647,
}
pub use self::ovrHandPinchStrength_ as ovrHandPinchStrength;
pub type ovrVertexIndex = i16;
impl ovrHandBone_ {
    pub const ovrHandBone_ThumbTip: ovrHandBone_ = ovrHandBone_::ovrHandBone_MaxSkinnable;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandBone_ {
    ovrHandBone_Invalid = -1,
    ovrHandBone_WristRoot = 0,
    ovrHandBone_ForearmStub = 1,
    ovrHandBone_Thumb0 = 2,
    ovrHandBone_Thumb1 = 3,
    ovrHandBone_Thumb2 = 4,
    ovrHandBone_Thumb3 = 5,
    ovrHandBone_Index1 = 6,
    ovrHandBone_Index2 = 7,
    ovrHandBone_Index3 = 8,
    ovrHandBone_Middle1 = 9,
    ovrHandBone_Middle2 = 10,
    ovrHandBone_Middle3 = 11,
    ovrHandBone_Ring1 = 12,
    ovrHandBone_Ring2 = 13,
    ovrHandBone_Ring3 = 14,
    ovrHandBone_Pinky0 = 15,
    ovrHandBone_Pinky1 = 16,
    ovrHandBone_Pinky2 = 17,
    ovrHandBone_Pinky3 = 18,
    ovrHandBone_MaxSkinnable = 19,
    ovrHandBone_IndexTip = 20,
    ovrHandBone_MiddleTip = 21,
    ovrHandBone_RingTip = 22,
    ovrHandBone_PinkyTip = 23,
    ovrHandBone_Max = 24,
    ovrHandBone_EnumSize = 32767,
}
pub use self::ovrHandBone_ as ovrHandBone;
pub type ovrHandBoneIndex = i16;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrConfidence_ {
    ovrConfidence_LOW = 0,
    ovrConfidence_HIGH = 1065353216,
}
pub use self::ovrConfidence_ as ovrConfidence;
#[repr(i32)]
#[doc = " Unified version struct"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandVersion_ {
    ovrHandVersion_1 = -553648127,
    #[doc = " Current"]
    ovrHandVersion_EnumSize = 2147483647,
}
#[doc = " Unified version struct"]
pub use self::ovrHandVersion_ as ovrHandVersion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrBoneCapsule_ {
    pub BoneIndex: ovrHandBoneIndex,
    pub Points: [ovrVector3f; 2usize],
    pub Radius: f32,
}
#[test]
fn bindgen_test_layout_ovrBoneCapsule_() {
    assert_eq!(
        ::std::mem::size_of::<ovrBoneCapsule_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrBoneCapsule_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrBoneCapsule_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrBoneCapsule_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrBoneCapsule_>())).BoneIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoneCapsule_),
            "::",
            stringify!(BoneIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrBoneCapsule_>())).Points as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoneCapsule_),
            "::",
            stringify!(Points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrBoneCapsule_>())).Radius as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoneCapsule_),
            "::",
            stringify!(Radius)
        )
    );
}
pub type ovrBoneCapsule = ovrBoneCapsule_;
impl ovrHandConstants_ {
    pub const ovrHand_MaxCapsules: ovrHandConstants_ = ovrHandConstants_::ovrHand_MaxSkinnableBones;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrHandConstants_ {
    ovrHand_MaxVertices = 3000,
    ovrHand_MaxIndices = 18000,
    ovrHand_MaxFingers = 5,
    ovrHand_MaxPinchStrengths = 4,
    ovrHand_MaxSkinnableBones = 19,
    ovrHand_MaxBones = 24,
    ovrHand_EnumSize = 2147483647,
}
pub use self::ovrHandConstants_ as ovrHandConstants;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrInputStateHandStatus_ {
    ovrInputStateHandStatus_PointerValid = 2,
    ovrInputStateHandStatus_IndexPinching = 4,
    ovrInputStateHandStatus_MiddlePinching = 8,
    ovrInputStateHandStatus_RingPinching = 16,
    ovrInputStateHandStatus_PinkyPinching = 32,
    ovrInputStateHandStatus_SystemGestureProcessing = 64,
    ovrInputStateHandStatus_DominantHand = 128,
    ovrInputStateHandStatus_MenuPressed = 256,
    ovrInputStateHandStatus_EnumSize = 2147483647,
}
pub use self::ovrInputStateHandStatus_ as ovrInputStateHandStatus;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrInputStateHand_ {
    pub Header: ovrInputStateHeader,
    pub PinchStrength: [f32; 4usize],
    pub PointerPose: ovrPosef,
    pub InputStateStatus: u32,
}
#[test]
fn bindgen_test_layout_ovrInputStateHand_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateHand_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrInputStateHand_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateHand_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateHand_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateHand_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHand_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHand_>())).PinchStrength as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHand_),
            "::",
            stringify!(PinchStrength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateHand_>())).PointerPose as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHand_),
            "::",
            stringify!(PointerPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHand_>())).InputStateStatus as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHand_),
            "::",
            stringify!(InputStateStatus)
        )
    );
}
pub type ovrInputStateHand = ovrInputStateHand_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHandPoseHeader_ {
    pub Version: ovrHandVersion,
    #[doc = " Reserved for later use"]
    pub Reserved: f64,
}
#[test]
fn bindgen_test_layout_ovrHandPoseHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHandPoseHeader_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrHandPoseHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHandPoseHeader_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHandPoseHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPoseHeader_>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPoseHeader_),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPoseHeader_>())).Reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPoseHeader_),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type ovrHandPoseHeader = ovrHandPoseHeader_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrHandPose_ {
    pub Header: ovrHandPoseHeader,
    pub Status: ovrHandTrackingStatus,
    pub RootPose: ovrPosef,
    pub BoneRotations: [ovrQuatf; 24usize],
    pub RequestedTimeStamp: f64,
    pub SampleTimeStamp: f64,
    pub HandConfidence: ovrConfidence,
    pub HandScale: f32,
    pub FingerConfidences: [ovrConfidence; 5usize],
}
#[test]
fn bindgen_test_layout_ovrHandPose_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHandPose_>(),
        480usize,
        concat!("Size of: ", stringify!(ovrHandPose_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHandPose_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHandPose_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).Status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).RootPose as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(RootPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).BoneRotations as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(BoneRotations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).RequestedTimeStamp as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(RequestedTimeStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).SampleTimeStamp as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(SampleTimeStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).HandConfidence as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(HandConfidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).HandScale as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(HandScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandPose_>())).FingerConfidences as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandPose_),
            "::",
            stringify!(FingerConfidences)
        )
    );
}
pub type ovrHandPose = ovrHandPose_;
extern "C" {
    pub fn vrapi_GetHandPose(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        absTimeInSeconds: f64,
        header: *mut ovrHandPoseHeader,
    ) -> ovrResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHandSkeletonHeader_ {
    pub Version: ovrHandVersion,
}
#[test]
fn bindgen_test_layout_ovrHandSkeletonHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHandSkeletonHeader_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrHandSkeletonHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHandSkeletonHeader_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrHandSkeletonHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandSkeletonHeader_>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeletonHeader_),
            "::",
            stringify!(Version)
        )
    );
}
pub type ovrHandSkeletonHeader = ovrHandSkeletonHeader_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrHandSkeleton_V1_ {
    pub Header: ovrHandSkeletonHeader,
    pub NumBones: u32,
    pub NumCapsules: u32,
    pub Reserved: [u32; 5usize],
    pub BonePoses: [ovrPosef; 24usize],
    pub BoneParentIndices: [ovrHandBoneIndex; 24usize],
    pub Capsules: [ovrBoneCapsule; 19usize],
}
#[test]
fn bindgen_test_layout_ovrHandSkeleton_V1_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHandSkeleton_V1_>(),
        1360usize,
        concat!("Size of: ", stringify!(ovrHandSkeleton_V1_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHandSkeleton_V1_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrHandSkeleton_V1_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandSkeleton_V1_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeleton_V1_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandSkeleton_V1_>())).NumBones as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeleton_V1_),
            "::",
            stringify!(NumBones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandSkeleton_V1_>())).NumCapsules as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeleton_V1_),
            "::",
            stringify!(NumCapsules)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandSkeleton_V1_>())).Reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeleton_V1_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandSkeleton_V1_>())).BonePoses as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeleton_V1_),
            "::",
            stringify!(BonePoses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrHandSkeleton_V1_>())).BoneParentIndices as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeleton_V1_),
            "::",
            stringify!(BoneParentIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandSkeleton_V1_>())).Capsules as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandSkeleton_V1_),
            "::",
            stringify!(Capsules)
        )
    );
}
pub type ovrHandSkeleton = ovrHandSkeleton_V1_;
extern "C" {
    pub fn vrapi_GetHandSkeleton(
        ovr: *mut ovrMobile,
        handedness: ovrHandedness,
        header: *mut ovrHandSkeletonHeader,
    ) -> ovrResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHandMeshHeader_ {
    pub Version: ovrHandVersion,
}
#[test]
fn bindgen_test_layout_ovrHandMeshHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHandMeshHeader_>(),
        4usize,
        concat!("Size of: ", stringify!(ovrHandMeshHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHandMeshHeader_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrHandMeshHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMeshHeader_>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMeshHeader_),
            "::",
            stringify!(Version)
        )
    );
}
pub type ovrHandMeshHeader = ovrHandMeshHeader_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrHandMesh_V1_ {
    pub Header: ovrHandMeshHeader,
    pub NumVertices: u32,
    pub NumIndices: u32,
    pub Reserved: [u32; 13usize],
    pub VertexPositions: [ovrVector3f; 3000usize],
    pub Indices: [ovrVertexIndex; 18000usize],
    pub VertexNormals: [ovrVector3f; 3000usize],
    pub VertexUV0: [ovrVector2f; 3000usize],
    pub BlendIndices: [ovrVector4s; 3000usize],
    pub BlendWeights: [ovrVector4f; 3000usize],
}
#[test]
fn bindgen_test_layout_ovrHandMesh_V1_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHandMesh_V1_>(),
        204064usize,
        concat!("Size of: ", stringify!(ovrHandMesh_V1_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHandMesh_V1_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrHandMesh_V1_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).NumVertices as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(NumVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).NumIndices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(NumIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).Reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).VertexPositions as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(VertexPositions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).Indices as *const _ as usize },
        36064usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(Indices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).VertexNormals as *const _ as usize },
        72064usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(VertexNormals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).VertexUV0 as *const _ as usize },
        108064usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(VertexUV0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).BlendIndices as *const _ as usize },
        132064usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(BlendIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHandMesh_V1_>())).BlendWeights as *const _ as usize },
        156064usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHandMesh_V1_),
            "::",
            stringify!(BlendWeights)
        )
    );
}
pub type ovrHandMesh = ovrHandMesh_V1_;
extern "C" {
    pub fn vrapi_GetHandMesh(
        ovr: *mut ovrMobile,
        handedness: ovrHandedness,
        header: *mut ovrHandMeshHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Enumerates the input devices connected to the system"]
    #[doc = " Start with index=0 and counting up. Stop when ovrResult is < 0"]
    #[doc = ""]
    #[doc = " Input: ovrMobile, device index, and a capabilities header"]
    #[doc = " The capabilities header does not need to have any fields set before calling."]
    #[doc = " Output: capabilitiesHeader with information for that enumeration index"]
    pub fn vrapi_EnumerateInputDevices(
        ovr: *mut ovrMobile,
        index: u32,
        capsHeader: *mut ovrInputCapabilityHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the capabilities of the input device for the corresponding device ID"]
    #[doc = ""]
    #[doc = " Input: ovr, pointer to a capabilities structure"]
    #[doc = " Output: capabilities will be filled with information for the deviceID"]
    #[doc = " Example:"]
    #[doc = "     The Type field of the capabilitiesHeader must be set when calling this function."]
    #[doc = "     Normally the capabilitiesHeader is obtained from the vrapi_EnumerateInputDevices API"]
    #[doc = "     The Type field in the header should match the structure type that is passed."]
    #[doc = ""]
    #[doc = "         ovrInputCapabilityHeader capsHeader;"]
    #[doc = "         if ( vrapi_EnumerateInputDevices( ovr, deviceIndex, &capsHeader ) >= 0 ) {"]
    #[doc = "             if ( capsHeader.Type == ovrDeviceType_TrackedRemote ) {"]
    #[doc = "                 ovrInputTrackedRemoteCapabilities remoteCaps;"]
    #[doc = "                 remoteCaps.Header = capsHeader;"]
    #[doc = "                 vrapi_GetInputDeviceCapabilities( ovr, &remoteCaps.Header );"]
    pub fn vrapi_GetInputDeviceCapabilities(
        ovr: *mut ovrMobile,
        capsHeader: *mut ovrInputCapabilityHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Sets the vibration level of a haptic device."]
    #[doc = " there should only be one call to vrapi_SetHapticVibrationSimple or"]
    #[doc = " vrapi_SetHapticVibrationBuffer per frame"]
    #[doc = "  additional calls of either will return ovrError_InvalidOperation and have undefined behavior"]
    #[doc = " Input: ovr, deviceID, intensity: 0.0 - 1.0"]
    pub fn vrapi_SetHapticVibrationSimple(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        intensity: f32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Fills the haptic vibration buffer of a haptic device"]
    #[doc = " there should only be one call to vrapi_SetHapticVibrationSimple or"]
    #[doc = " vrapi_SetHapticVibrationBuffer per frame"]
    #[doc = "  additional calls of either will return ovrError_InvalidOperation and have undefined behavior"]
    #[doc = " Input: ovr, deviceID, pointer to a hapticBuffer with filled in data."]
    pub fn vrapi_SetHapticVibrationBuffer(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        hapticBuffer: *const ovrHapticBuffer,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the current input state for controllers, without positional tracking info."]
    #[doc = ""]
    #[doc = " Input: ovr, deviceID, pointer to a capabilities structure (with Type field set)"]
    #[doc = " Output: Upon return the inputState structure will be set to the device's current input state"]
    #[doc = " Example:"]
    #[doc = "     The Type field of the passed ovrInputStateHeader must be set to the type that"]
    #[doc = "     corresponds to the type of structure being passed."]
    #[doc = "     The pointer to the ovrInputStateHeader should be a pointer to a Header field in"]
    #[doc = "     structure matching the value of the Type field."]
    #[doc = ""]
    #[doc = "     ovrInputStateTrackedRemote state;"]
    #[doc = "     state.Header.Type = ovrControllerType_TrackedRemote;"]
    #[doc = "     if ( vrapi_GetCurrentInputState( ovr, remoteDeviceID, &state.Header ) >= 0 ) {"]
    pub fn vrapi_GetCurrentInputState(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        inputState: *mut ovrInputStateHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the predicted input state based on the specified absolute system time"]
    #[doc = " in seconds. Pass absTime value of 0.0 to request the most recent sensor reading."]
    #[doc = " Input: ovr, device ID, prediction time"]
    #[doc = " Output: ovrTracking structure containing the device's predicted tracking state."]
    pub fn vrapi_GetInputTrackingState(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        absTimeInSeconds: f64,
        tracking: *mut ovrTracking,
    ) -> ovrResult;
}
extern "C" {
    pub fn vrapi_RecenterInputPose(ovr: *mut ovrMobile, deviceID: ovrDeviceID);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ovrFrameInit {
    VRAPI_FRAME_INIT_DEFAULT = 0,
    VRAPI_FRAME_INIT_BLACK = 1,
    VRAPI_FRAME_INIT_BLACK_FLUSH = 2,
    VRAPI_FRAME_INIT_BLACK_FINAL = 3,
    VRAPI_FRAME_INIT_LOADING_ICON = 4,
    VRAPI_FRAME_INIT_LOADING_ICON_FLUSH = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
extern "C" {
    #[doc = " Returns a list of strings delimited by a single space identifying Vulkan extensions that must"]
    #[doc = " be enabled for the instance in order for the VR runtime to support Vulkan-based applications."]
    pub fn vrapi_GetInstanceExtensionsVulkan(
        extensionNames: *mut ::std::os::raw::c_char,
        extensionNamesSize: *mut u32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns a list of strings delimited by a single space identifying Vulkan extensions that must"]
    #[doc = " be enabled for the device in order for the VR runtime to support Vulkan-based applications."]
    pub fn vrapi_GetDeviceExtensionsVulkan(
        extensionNames: *mut ::std::os::raw::c_char,
        extensionNamesSize: *mut u32,
    ) -> ovrResult;
}
#[doc = " Initialization parameters unique to Vulkan."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrSystemCreateInfoVulkan_ {
    pub Instance: VkInstance,
    pub PhysicalDevice: VkPhysicalDevice,
    pub Device: VkDevice,
}
#[test]
fn bindgen_test_layout_ovrSystemCreateInfoVulkan_() {
    assert_eq!(
        ::std::mem::size_of::<ovrSystemCreateInfoVulkan_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrSystemCreateInfoVulkan_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrSystemCreateInfoVulkan_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrSystemCreateInfoVulkan_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSystemCreateInfoVulkan_>())).Instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSystemCreateInfoVulkan_),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSystemCreateInfoVulkan_>())).PhysicalDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSystemCreateInfoVulkan_),
            "::",
            stringify!(PhysicalDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSystemCreateInfoVulkan_>())).Device as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSystemCreateInfoVulkan_),
            "::",
            stringify!(Device)
        )
    );
}
#[doc = " Initialization parameters unique to Vulkan."]
pub type ovrSystemCreateInfoVulkan = ovrSystemCreateInfoVulkan_;
extern "C" {
    #[doc = " Initializes the API for Vulkan support."]
    #[doc = " This is lightweight and does not create any threads."]
    #[doc = " This is called after vrapi_Initialize and before texture swapchain creation, or"]
    #[doc = " vrapi_enterVrMode."]
    pub fn vrapi_CreateSystemVulkan(systemInfo: *mut ovrSystemCreateInfoVulkan) -> ovrResult;
}
extern "C" {
    #[doc = " Destroys the API for Vulkan support."]
    #[doc = " This is called before vrapi_Shutdown."]
    pub fn vrapi_DestroySystemVulkan();
}
extern "C" {
    #[doc = " Get the VkImage at the given index within the chain."]
    pub fn vrapi_GetTextureSwapChainBufferVulkan(
        chain: *mut ovrTextureSwapChain,
        index: ::std::os::raw::c_int,
    ) -> VkImage;
}
extern "C" {
    #[doc = " Get the foveation VkImage and corresponding size at the given index within the chain."]
    #[doc = " In case of failure, this returns a null image handle and zero width and height."]
    pub fn vrapi_GetTextureSwapChainBufferFoveationVulkan(
        chain: *mut ovrTextureSwapChain,
        index: ::std::os::raw::c_int,
        image: *mut VkImage,
        imageWidth: *mut u32,
        imageHeight: *mut u32,
    ) -> ovrResult;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
